{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"iCrowd Simulation Tool Documentation Overview A comprehensive crowd simulation system designed for architectural visualization, urban planning, film production, and game development. This tool provides both static distribution and dynamic movement capabilities through integrated systems that work together seamlessly. System Architecture Static Distribution Systems On Ground System - Terrain-based scattering across surfaces - Flexible density control with vertex group masking - Support for individual agents and cluster formations - Natural variation with noise and randomization On Curve System - Path-based distributions with width control - Curve radius scaling for dynamic density - Automatic agent orientation along paths - Count-based or density-based placement options On Vertex System - Precision placement on mesh vertices - Custom patterns through vertex group selection - Ideal for architectural layouts and exact formations - Weight painting support for density gradients Stadium System - Organized seating and venue layouts - Four input methods: On Face, On Instance, On Collection, On Vertex - Grid-based control for row/column arrangements - Rotation and transformation controls for perfect alignment Walkers System - Structured path-based crowd flows - Lane management with count and direction control - Personal space and density management - Noise parameters for natural variations City System - Urban environment placements - Activity-based behaviors (sleep, eat, work, fun) - Infrastructure-aware distribution (roads, sidewalks) - Collision management and time-based patterns Dynamic Control System Fluid System - Real-time movement simulation - Multiple control methods: Path following, Attraction, Repulsion - Physics-based behaviors with speed controls - Integration with all static distribution systems Key Features Distribution Capabilities Multiple static systems for different scenarios Vertex group masking for precise control Density gradients and natural variations Support for individual agents and collections Movement Control Path following with curve-based direction Attraction/repulsion systems for goal-oriented behavior Real-time parameter adjustment Physics-based collision avoidance Performance Optimization Scalable from small groups to massive crowds Baking capabilities for complex simulations LOD support for real-time applications Efficient memory management Workflow Integration Standard Pipeline Static Placement : Choose appropriate static system for initial distribution Density Refinement : Adjust parameters and masking for desired layout Dynamic Activation : Import static setup into Fluid system for movement Behavior Tuning : Configure paths, attractors, and repellers Final Polish : Adjust variations and performance settings System Combinations Urban Scenes : City system + Fluid system Structured Events : Walkers system + Stadium system Architectural Visualization : On Vertex system + Fluid system Complex Productions : Combined use of all systems Getting Started Quick Start Guides Basic terrain scattering with On Ground system Path-based crowds with On Curve system Venue seating with Stadium system Dynamic crowds with Fluid system System Selection Guide For natural environments : On Ground system For path-based flows : On Curve or Walkers systems For precise placements : On Vertex system For venue seating : Stadium system For urban environments : City system For dynamic movement : Fluid system Documentation Structure System Documentation Detailed parameter explanations for each system Workflow examples and use cases Performance optimization guidelines Troubleshooting common issues Tutorial Section Step-by-step project tutorials Video demonstrations Example files and templates Advanced technique showcases FAQ & Support Common questions and solutions Technical troubleshooting Best practices and tips Community resources Technical Specifications Compatibility Node-based workflow integration Standard 3D modeling software compatibility Export capabilities for game engines and renderers Cross-platform performance optimization System Requirements Detailed hardware recommendations Memory and processing requirements GPU acceleration support Scalability considerations Support Resources Learning Materials Video tutorials for all skill levels Interactive example files Project templates and presets Community showcase gallery Community & Updates User forum for questions and sharing Regular system updates and improvements Feature request system Bug reporting and tracking This documentation covers the complete crowd simulation ecosystem. Use the navigation to explore specific systems or jump to tutorials for hands-on learning.","title":"Home"},{"location":"#icrowd-simulation-tool-documentation","text":"","title":"iCrowd Simulation Tool Documentation"},{"location":"#overview","text":"A comprehensive crowd simulation system designed for architectural visualization, urban planning, film production, and game development. This tool provides both static distribution and dynamic movement capabilities through integrated systems that work together seamlessly.","title":"Overview"},{"location":"#system-architecture","text":"","title":"System Architecture"},{"location":"#static-distribution-systems","text":"On Ground System - Terrain-based scattering across surfaces - Flexible density control with vertex group masking - Support for individual agents and cluster formations - Natural variation with noise and randomization On Curve System - Path-based distributions with width control - Curve radius scaling for dynamic density - Automatic agent orientation along paths - Count-based or density-based placement options On Vertex System - Precision placement on mesh vertices - Custom patterns through vertex group selection - Ideal for architectural layouts and exact formations - Weight painting support for density gradients Stadium System - Organized seating and venue layouts - Four input methods: On Face, On Instance, On Collection, On Vertex - Grid-based control for row/column arrangements - Rotation and transformation controls for perfect alignment Walkers System - Structured path-based crowd flows - Lane management with count and direction control - Personal space and density management - Noise parameters for natural variations City System - Urban environment placements - Activity-based behaviors (sleep, eat, work, fun) - Infrastructure-aware distribution (roads, sidewalks) - Collision management and time-based patterns","title":"Static Distribution Systems"},{"location":"#dynamic-control-system","text":"Fluid System - Real-time movement simulation - Multiple control methods: Path following, Attraction, Repulsion - Physics-based behaviors with speed controls - Integration with all static distribution systems","title":"Dynamic Control System"},{"location":"#key-features","text":"","title":"Key Features"},{"location":"#distribution-capabilities","text":"Multiple static systems for different scenarios Vertex group masking for precise control Density gradients and natural variations Support for individual agents and collections","title":"Distribution Capabilities"},{"location":"#movement-control","text":"Path following with curve-based direction Attraction/repulsion systems for goal-oriented behavior Real-time parameter adjustment Physics-based collision avoidance","title":"Movement Control"},{"location":"#performance-optimization","text":"Scalable from small groups to massive crowds Baking capabilities for complex simulations LOD support for real-time applications Efficient memory management","title":"Performance Optimization"},{"location":"#workflow-integration","text":"","title":"Workflow Integration"},{"location":"#standard-pipeline","text":"Static Placement : Choose appropriate static system for initial distribution Density Refinement : Adjust parameters and masking for desired layout Dynamic Activation : Import static setup into Fluid system for movement Behavior Tuning : Configure paths, attractors, and repellers Final Polish : Adjust variations and performance settings","title":"Standard Pipeline"},{"location":"#system-combinations","text":"Urban Scenes : City system + Fluid system Structured Events : Walkers system + Stadium system Architectural Visualization : On Vertex system + Fluid system Complex Productions : Combined use of all systems","title":"System Combinations"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#quick-start-guides","text":"Basic terrain scattering with On Ground system Path-based crowds with On Curve system Venue seating with Stadium system Dynamic crowds with Fluid system","title":"Quick Start Guides"},{"location":"#system-selection-guide","text":"For natural environments : On Ground system For path-based flows : On Curve or Walkers systems For precise placements : On Vertex system For venue seating : Stadium system For urban environments : City system For dynamic movement : Fluid system","title":"System Selection Guide"},{"location":"#documentation-structure","text":"","title":"Documentation Structure"},{"location":"#system-documentation","text":"Detailed parameter explanations for each system Workflow examples and use cases Performance optimization guidelines Troubleshooting common issues","title":"System Documentation"},{"location":"#tutorial-section","text":"Step-by-step project tutorials Video demonstrations Example files and templates Advanced technique showcases","title":"Tutorial Section"},{"location":"#faq-support","text":"Common questions and solutions Technical troubleshooting Best practices and tips Community resources","title":"FAQ &amp; Support"},{"location":"#technical-specifications","text":"","title":"Technical Specifications"},{"location":"#compatibility","text":"Node-based workflow integration Standard 3D modeling software compatibility Export capabilities for game engines and renderers Cross-platform performance optimization","title":"Compatibility"},{"location":"#system-requirements","text":"Detailed hardware recommendations Memory and processing requirements GPU acceleration support Scalability considerations","title":"System Requirements"},{"location":"#support-resources","text":"","title":"Support Resources"},{"location":"#learning-materials","text":"Video tutorials for all skill levels Interactive example files Project templates and presets Community showcase gallery","title":"Learning Materials"},{"location":"#community-updates","text":"User forum for questions and sharing Regular system updates and improvements Feature request system Bug reporting and tracking This documentation covers the complete crowd simulation ecosystem. Use the navigation to explore specific systems or jump to tutorials for hands-on learning.","title":"Community &amp; Updates"},{"location":"faq/","text":"iCrowd Simulation Tool - Complete FAQ General Questions \ud83e\udd14 What's the difference between the four static systems? On Ground : For scattering across surfaces/terrains (most flexible) On Curve : For path-based distributions with width control On Vertex : For precise placement on mesh vertices Stadium : For organized seating/venue layouts with multiple input methods Walkers : For structured path-based crowd flows City : For urban environment placements with activities Fluid : For dynamic movement control (not static) \u26a1 Which static system is fastest for large crowds? Performance Ranking : 1. On Ground - Best for massive terrain scattering 2. On Curve - Efficient for linear path distributions 3. Stadium - Optimized for organized layouts 4. On Vertex - Precision placement (slower with high vertex counts) 5. Walkers - Complex path-based logic 6. City - Activity system adds overhead \ud83d\udd04 Can I combine multiple static systems? Yes! Recommended combinations : - Stadium + On Ground : Seating areas + standing crowds - On Curve + On Vertex : Pathways + specific points of interest - Walkers + City : Structured flows + environmental crowds - All systems can be layered for complex scenes On Ground System FAQ \ud83c\udf0d When should I use Singles vs Clusters? Singles : Individual people, random scattering, natural distributions Clusters : Group formations, families, conversation groups, organized patterns \ud83c\udfaf How does vertex group masking work? Paint vertex weights on your terrain: - White areas : Full density - Black areas : No agents - Gray areas : Proportional density - Perfect for creating natural density variations \ud83d\udccf What's the difference between Min Distance and Personal Space? Min Distance : Hard limit - agents never get closer than this Personal Space : Soft constraint - system tries to maintain this distance but may vary for natural look On Curve System FAQ \ud83d\udee3\ufe0f How do I control density along curves? Use curve point radius scaling : - Wider radius = more agents in that area - Narrower radius = fewer agents - Adjust Radius Multiplier to amplify/reduce this effect \ud83d\udcd0 Count vs Density placement? Count : Fixed number of agents distributed along entire curve Density : Agents per unit length - automatically adjusts to curve length \ud83d\udd04 Can agents follow complex curved paths? Yes! The system automatically orients agents to follow curve direction. Use Look Direction settings to fine-tune. On Vertex System FAQ \ud83d\udccd What's the advantage over regular scattering? Precision control : Each agent placed on exact vertices, perfect for: - Architectural layouts - Predefined seating patterns - Data visualization - Exact formations \ud83c\udfa8 How do I create custom patterns? Use vertex groups to select specific vertices: - Create vertex group with only desired vertices - System places agents only on selected points - Perfect for logos, text, or specific patterns \ud83d\udcca Performance with high-vertex meshes? The system is optimized, but very dense meshes (100k+ vertices) may slow down. Use Max parameter to limit agent count. Stadium System FAQ \ud83c\udfdf\ufe0f What are the four distribution methods? On Face : Grid-based placement on surfaces (most flexible) On Instance : Use existing geometry node instances (fastest) On Collection : Distribute across scene objects On Vertex : Precise vertex-based control \ud83d\udcba Which method is best for theater seating? Recommended workflow : 1. On Instance with chair geometry nodes (performance) 2. On Vertex with seat vertex layout (precision) 3. Adjust Fill Factor for occupancy rate 4. Use Rotation Type for proper audience orientation \ud83d\udcd0 On Face method - why do I need UVs? UVs ensure proper grid distribution across the face. Just add a simple plane and scale it - the system handles UVs automatically. \ud83c\udfaa How do I create different seating sections? Section control methods : - Weight Painting : Paint density variations on the surface - Vertex Groups : Define different sections with vertex groups - Fill Factor : Control overall occupancy percentage - Multi-object : Use different agent types for different sections Walkers System FAQ \ud83d\udee3\ufe0f When should I use Walkers vs On Curve? Walkers : Complex behaviors, lane management, structured flows On Curve : Simple path following, faster setup Use Walkers for intelligent crowd behaviors, On Curve for basic path following \ud83d\udccf How do I control agent spacing in Walkers? Personal Space Min/Max : Sets minimum and desired distances Density : Overall crowd concentration Noise : Adds natural variation to spacing Lanes : Separate flow paths with individual control \ud83d\udd04 What's the difference between Lanes Count and Density? Lanes Count : Number of parallel paths for agent flow Density : How closely agents are packed within each lane Use both for complex multi-lane scenarios City System FAQ \ud83c\udfd9\ufe0f What makes City system unique for urban scenes? Activity-based behaviors : Agents have states (sleep, eat, work, fun) Infrastructure-aware : Automatically respects roads, sidewalks, buildings Collision management : Built-in avoidance for urban obstacles Time-based patterns : Activities follow day/night cycles \ud83c\udfaf How do Activities work? Each activity (ADM_fun, ADM_sleep, etc.) defines: - Location : Where the activity occurs - Timing : When agents engage - Behavior : How agents act during activities - Collections : Groups of related objects \ud83c\udf06 Best workflow for city scenes? Set up ICity infrastructure (roads, sidewalks) Define Activities and their locations Configure Density and Mask for natural distribution Add Custom elements and colliders Fluid System FAQ \ud83c\udf0a How do I transition from static to dynamic? Three-step process: 1. Create static distribution with any static system 2. Import into Fluid system via density inputs 3. Activate movement with curves, attractors, or repellers \ud83c\udfae What movement control methods are available? Path Following : Agents follow curve direction Attraction : Move toward target objects Repulsion : Avoid specific areas/objects Combined : Use all three simultaneously \u26a1 How do I control simulation speed? Speed Settings : - Walk Speed : Normal movement (m/s) - Run Speed : Fast movement (m/s) - Max Speed : Velocity cap - Relax Iterations : Physics smoothing Technical Issues & Performance \u26a0\ufe0f Agents floating above ground? Check Terrain object is properly set Ensure Up Direction matches scene orientation Verify agent pivot points are correct \ud83d\udd04 Rotation looks wrong? Adjust Up Direction for surface alignment Set Look Direction for forward orientation Use Rotation variations for natural randomness \ud83d\udc0c System running slow? Reduce Relax Iterations (start with 3-5) Lower agent count with Max parameter Use simpler agent meshes during setup Disable viewport preview when not needed Workflow Tips & Best Practices \ud83c\udfa8 How to make crowds look natural? Always use Scale and Rotation variations Mix agent types with Collections Add Noise parameters to break patterns Use Personal Space ranges, not fixed distances \ud83c\udfd7\ufe0f Best pipeline for complex scenes? Blocking : Simple proxies with basic systems Layout : Refine density and distribution Animation : Add movement with Fluid system Polish : Fine-tune behaviors and variations \ud83c\udfac Preparing for different use cases? Architectural Visualization : - City system for environment setup - Moderate density with natural variations Event Planning : - Walkers for structured flow patterns - Stadium for seating arrangements Entertainment : - All systems combined for complexity - Exaggerated behaviors for visual appeal Advanced Techniques \ud83c\udf0a Creating density gradients? Methods by system : - On Ground : Vertex group painting - On Curve : Vary curve radius along path - Stadium : Weight painting for section density - City : Activity-based density variations \ud83c\udfad Mixing agent types and behaviors? Use Collections with multiple objects Assign different activities to agent groups Create behavior variations through parameters Use vertex groups for type distributions \ud83d\udcf1 Optimizing for real-time/game engines? Use low-poly agent meshes with LODs Bake animations when possible Reduce texture resolutions Use instancing for duplicate agents Troubleshooting Common Problems \u274c No agents appearing? Check Max parameter isn't set to 0 Verify terrain/curve references are valid Ensure vertex groups aren't completely masked Confirm all required inputs are connected \ud83d\udd00 Agents clipping through each other? Increase Min Distance or Personal Space Add more Relax Iterations Use Space Min/Max for tighter control \ud83d\udcd0 Scale issues between systems? Consistent unit scale across all systems Match terrain scale to agent proportions Adjust Speed parameters relative to scene size \ud83c\udfaf Attract/Repel systems not working? Confirm objects are properly referenced Check distance ranges are appropriate Verify systems are enabled in controls Test with exaggerated values first Need more help? Check our video tutorials and example files for visual guidance on complex setups! The community forum also has advanced techniques shared by other users.","title":"FAQ"},{"location":"faq/#icrowd-simulation-tool-complete-faq","text":"","title":"iCrowd Simulation Tool - Complete FAQ"},{"location":"faq/#general-questions","text":"","title":"General Questions"},{"location":"faq/#whats-the-difference-between-the-four-static-systems","text":"On Ground : For scattering across surfaces/terrains (most flexible) On Curve : For path-based distributions with width control On Vertex : For precise placement on mesh vertices Stadium : For organized seating/venue layouts with multiple input methods Walkers : For structured path-based crowd flows City : For urban environment placements with activities Fluid : For dynamic movement control (not static)","title":"\ud83e\udd14 What's the difference between the four static systems?"},{"location":"faq/#which-static-system-is-fastest-for-large-crowds","text":"Performance Ranking : 1. On Ground - Best for massive terrain scattering 2. On Curve - Efficient for linear path distributions 3. Stadium - Optimized for organized layouts 4. On Vertex - Precision placement (slower with high vertex counts) 5. Walkers - Complex path-based logic 6. City - Activity system adds overhead","title":"\u26a1 Which static system is fastest for large crowds?"},{"location":"faq/#can-i-combine-multiple-static-systems","text":"Yes! Recommended combinations : - Stadium + On Ground : Seating areas + standing crowds - On Curve + On Vertex : Pathways + specific points of interest - Walkers + City : Structured flows + environmental crowds - All systems can be layered for complex scenes","title":"\ud83d\udd04 Can I combine multiple static systems?"},{"location":"faq/#on-ground-system-faq","text":"","title":"On Ground System FAQ"},{"location":"faq/#when-should-i-use-singles-vs-clusters","text":"Singles : Individual people, random scattering, natural distributions Clusters : Group formations, families, conversation groups, organized patterns","title":"\ud83c\udf0d When should I use Singles vs Clusters?"},{"location":"faq/#how-does-vertex-group-masking-work","text":"Paint vertex weights on your terrain: - White areas : Full density - Black areas : No agents - Gray areas : Proportional density - Perfect for creating natural density variations","title":"\ud83c\udfaf How does vertex group masking work?"},{"location":"faq/#whats-the-difference-between-min-distance-and-personal-space","text":"Min Distance : Hard limit - agents never get closer than this Personal Space : Soft constraint - system tries to maintain this distance but may vary for natural look","title":"\ud83d\udccf What's the difference between Min Distance and Personal Space?"},{"location":"faq/#on-curve-system-faq","text":"","title":"On Curve System FAQ"},{"location":"faq/#how-do-i-control-density-along-curves","text":"Use curve point radius scaling : - Wider radius = more agents in that area - Narrower radius = fewer agents - Adjust Radius Multiplier to amplify/reduce this effect","title":"\ud83d\udee3\ufe0f How do I control density along curves?"},{"location":"faq/#count-vs-density-placement","text":"Count : Fixed number of agents distributed along entire curve Density : Agents per unit length - automatically adjusts to curve length","title":"\ud83d\udcd0 Count vs Density placement?"},{"location":"faq/#can-agents-follow-complex-curved-paths","text":"Yes! The system automatically orients agents to follow curve direction. Use Look Direction settings to fine-tune.","title":"\ud83d\udd04 Can agents follow complex curved paths?"},{"location":"faq/#on-vertex-system-faq","text":"","title":"On Vertex System FAQ"},{"location":"faq/#whats-the-advantage-over-regular-scattering","text":"Precision control : Each agent placed on exact vertices, perfect for: - Architectural layouts - Predefined seating patterns - Data visualization - Exact formations","title":"\ud83d\udccd What's the advantage over regular scattering?"},{"location":"faq/#how-do-i-create-custom-patterns","text":"Use vertex groups to select specific vertices: - Create vertex group with only desired vertices - System places agents only on selected points - Perfect for logos, text, or specific patterns","title":"\ud83c\udfa8 How do I create custom patterns?"},{"location":"faq/#performance-with-high-vertex-meshes","text":"The system is optimized, but very dense meshes (100k+ vertices) may slow down. Use Max parameter to limit agent count.","title":"\ud83d\udcca Performance with high-vertex meshes?"},{"location":"faq/#stadium-system-faq","text":"","title":"Stadium System FAQ"},{"location":"faq/#what-are-the-four-distribution-methods","text":"On Face : Grid-based placement on surfaces (most flexible) On Instance : Use existing geometry node instances (fastest) On Collection : Distribute across scene objects On Vertex : Precise vertex-based control","title":"\ud83c\udfdf\ufe0f What are the four distribution methods?"},{"location":"faq/#which-method-is-best-for-theater-seating","text":"Recommended workflow : 1. On Instance with chair geometry nodes (performance) 2. On Vertex with seat vertex layout (precision) 3. Adjust Fill Factor for occupancy rate 4. Use Rotation Type for proper audience orientation","title":"\ud83d\udcba Which method is best for theater seating?"},{"location":"faq/#on-face-method-why-do-i-need-uvs","text":"UVs ensure proper grid distribution across the face. Just add a simple plane and scale it - the system handles UVs automatically.","title":"\ud83d\udcd0 On Face method - why do I need UVs?"},{"location":"faq/#how-do-i-create-different-seating-sections","text":"Section control methods : - Weight Painting : Paint density variations on the surface - Vertex Groups : Define different sections with vertex groups - Fill Factor : Control overall occupancy percentage - Multi-object : Use different agent types for different sections","title":"\ud83c\udfaa How do I create different seating sections?"},{"location":"faq/#walkers-system-faq","text":"","title":"Walkers System FAQ"},{"location":"faq/#when-should-i-use-walkers-vs-on-curve","text":"Walkers : Complex behaviors, lane management, structured flows On Curve : Simple path following, faster setup Use Walkers for intelligent crowd behaviors, On Curve for basic path following","title":"\ud83d\udee3\ufe0f When should I use Walkers vs On Curve?"},{"location":"faq/#how-do-i-control-agent-spacing-in-walkers","text":"Personal Space Min/Max : Sets minimum and desired distances Density : Overall crowd concentration Noise : Adds natural variation to spacing Lanes : Separate flow paths with individual control","title":"\ud83d\udccf How do I control agent spacing in Walkers?"},{"location":"faq/#whats-the-difference-between-lanes-count-and-density","text":"Lanes Count : Number of parallel paths for agent flow Density : How closely agents are packed within each lane Use both for complex multi-lane scenarios","title":"\ud83d\udd04 What's the difference between Lanes Count and Density?"},{"location":"faq/#city-system-faq","text":"","title":"City System FAQ"},{"location":"faq/#what-makes-city-system-unique-for-urban-scenes","text":"Activity-based behaviors : Agents have states (sleep, eat, work, fun) Infrastructure-aware : Automatically respects roads, sidewalks, buildings Collision management : Built-in avoidance for urban obstacles Time-based patterns : Activities follow day/night cycles","title":"\ud83c\udfd9\ufe0f What makes City system unique for urban scenes?"},{"location":"faq/#how-do-activities-work","text":"Each activity (ADM_fun, ADM_sleep, etc.) defines: - Location : Where the activity occurs - Timing : When agents engage - Behavior : How agents act during activities - Collections : Groups of related objects","title":"\ud83c\udfaf How do Activities work?"},{"location":"faq/#best-workflow-for-city-scenes","text":"Set up ICity infrastructure (roads, sidewalks) Define Activities and their locations Configure Density and Mask for natural distribution Add Custom elements and colliders","title":"\ud83c\udf06 Best workflow for city scenes?"},{"location":"faq/#fluid-system-faq","text":"","title":"Fluid System FAQ"},{"location":"faq/#how-do-i-transition-from-static-to-dynamic","text":"Three-step process: 1. Create static distribution with any static system 2. Import into Fluid system via density inputs 3. Activate movement with curves, attractors, or repellers","title":"\ud83c\udf0a How do I transition from static to dynamic?"},{"location":"faq/#what-movement-control-methods-are-available","text":"Path Following : Agents follow curve direction Attraction : Move toward target objects Repulsion : Avoid specific areas/objects Combined : Use all three simultaneously","title":"\ud83c\udfae What movement control methods are available?"},{"location":"faq/#how-do-i-control-simulation-speed","text":"Speed Settings : - Walk Speed : Normal movement (m/s) - Run Speed : Fast movement (m/s) - Max Speed : Velocity cap - Relax Iterations : Physics smoothing","title":"\u26a1 How do I control simulation speed?"},{"location":"faq/#technical-issues-performance","text":"","title":"Technical Issues &amp; Performance"},{"location":"faq/#agents-floating-above-ground","text":"Check Terrain object is properly set Ensure Up Direction matches scene orientation Verify agent pivot points are correct","title":"\u26a0\ufe0f Agents floating above ground?"},{"location":"faq/#rotation-looks-wrong","text":"Adjust Up Direction for surface alignment Set Look Direction for forward orientation Use Rotation variations for natural randomness","title":"\ud83d\udd04 Rotation looks wrong?"},{"location":"faq/#system-running-slow","text":"Reduce Relax Iterations (start with 3-5) Lower agent count with Max parameter Use simpler agent meshes during setup Disable viewport preview when not needed","title":"\ud83d\udc0c System running slow?"},{"location":"faq/#workflow-tips-best-practices","text":"","title":"Workflow Tips &amp; Best Practices"},{"location":"faq/#how-to-make-crowds-look-natural","text":"Always use Scale and Rotation variations Mix agent types with Collections Add Noise parameters to break patterns Use Personal Space ranges, not fixed distances","title":"\ud83c\udfa8 How to make crowds look natural?"},{"location":"faq/#best-pipeline-for-complex-scenes","text":"Blocking : Simple proxies with basic systems Layout : Refine density and distribution Animation : Add movement with Fluid system Polish : Fine-tune behaviors and variations","title":"\ud83c\udfd7\ufe0f Best pipeline for complex scenes?"},{"location":"faq/#preparing-for-different-use-cases","text":"Architectural Visualization : - City system for environment setup - Moderate density with natural variations Event Planning : - Walkers for structured flow patterns - Stadium for seating arrangements Entertainment : - All systems combined for complexity - Exaggerated behaviors for visual appeal","title":"\ud83c\udfac Preparing for different use cases?"},{"location":"faq/#advanced-techniques","text":"","title":"Advanced Techniques"},{"location":"faq/#creating-density-gradients","text":"Methods by system : - On Ground : Vertex group painting - On Curve : Vary curve radius along path - Stadium : Weight painting for section density - City : Activity-based density variations","title":"\ud83c\udf0a Creating density gradients?"},{"location":"faq/#mixing-agent-types-and-behaviors","text":"Use Collections with multiple objects Assign different activities to agent groups Create behavior variations through parameters Use vertex groups for type distributions","title":"\ud83c\udfad Mixing agent types and behaviors?"},{"location":"faq/#optimizing-for-real-timegame-engines","text":"Use low-poly agent meshes with LODs Bake animations when possible Reduce texture resolutions Use instancing for duplicate agents","title":"\ud83d\udcf1 Optimizing for real-time/game engines?"},{"location":"faq/#troubleshooting-common-problems","text":"","title":"Troubleshooting Common Problems"},{"location":"faq/#no-agents-appearing","text":"Check Max parameter isn't set to 0 Verify terrain/curve references are valid Ensure vertex groups aren't completely masked Confirm all required inputs are connected","title":"\u274c No agents appearing?"},{"location":"faq/#agents-clipping-through-each-other","text":"Increase Min Distance or Personal Space Add more Relax Iterations Use Space Min/Max for tighter control","title":"\ud83d\udd00 Agents clipping through each other?"},{"location":"faq/#scale-issues-between-systems","text":"Consistent unit scale across all systems Match terrain scale to agent proportions Adjust Speed parameters relative to scene size","title":"\ud83d\udcd0 Scale issues between systems?"},{"location":"faq/#attractrepel-systems-not-working","text":"Confirm objects are properly referenced Check distance ranges are appropriate Verify systems are enabled in controls Test with exaggerated values first Need more help? Check our video tutorials and example files for visual guidance on complex setups! The community forum also has advanced techniques shared by other users.","title":"\ud83c\udfaf Attract/Repel systems not working?"},{"location":"tutorials/","text":"Fill a stadium Import stadium model Static > Stadium Set rows/seats Assign characters Render","title":"Tutorials"},{"location":"tutorials/#fill-a-stadium","text":"Import stadium model Static > Stadium Set rows/seats Assign characters Render","title":"Fill a stadium"},{"location":"dynamic/","text":"Dynamic iCrowd Simulation - System Overview Three Integrated Systems 1. Walkers System - Static Path-Based Distribution Purpose : Create structured, lane-based crowd placements along defined paths Core Functionality : - Path-following agent distribution along curves and lanes - Controlled density with personal space management - Predictable, organized crowd patterns - Ideal for parades, guided flows, structured movement Key Components : Lanes, Walkers Curves, Noise controls, Personal Space settings 2. City System - Static Urban Distribution Purpose : Environment-aware crowd placement for urban scenarios Core Functionality : - Terrain and infrastructure-based distribution (roads, sidewalks) - Activity-based agent behaviors (sleep, eat, work, leisure) - Collision-aware placement with environmental constraints - Urban-scale crowd simulation setup Key Components : ICity infrastructure, Activities system, Collision objects, Mask controls 3. Fluid System - Dynamic Movement Control Purpose : Transform static distributions into living, responsive crowds Core Functionality : - Real-time movement simulation with physics-based behaviors - Multi-method control (path following, attraction, repulsion) - Dynamic response to environmental changes - Smooth, natural crowd flow and interactions Key Components : Motion engine, Flow Curves, Attract/Repel systems, Real-time controls Integrated Workflow Phase 1: Static Setup Use Walkers for structured path-based distributions Use City for environment-aware urban placements Both systems output density maps and agent configurations Phase 2: Dynamic Activation Fluid system imports static distributions Applies motion behaviors and interactive controls Enables real-time crowd movement and responses Phase 3: Runtime Control Adjust movement parameters in real-time Modify attractors/repellers during simulation Monitor and tweak crowd behaviors dynamically System Relationships Static Systems (Walkers/City) \u2192 Fluid System \u2192 Dynamic Simulation \u2193 \u2193 Distribution Setup Movement Control \u2193 \u2193 Agent Placement Real-time Behavior Unique Capabilities Walkers System Specialization Precise lane control and flow direction Looping paths and structured formations Ideal for controlled crowd movements City System Specialization Urban environment integration Activity-based behavior states Complex collision and space management Fluid System Specialization Real-time dynamic control Multiple simultaneous movement methods Physics-based natural interactions Use Case Scenarios Architectural Visualization : City (placement) \u2192 Fluid (movement) Event Planning : Walkers (structured flow) \u2192 Fluid (dynamic behavior) Urban Analysis : City (environment setup) \u2192 Fluid (traffic simulation) Entertainment : Combined use for complex crowd scenes This three-system approach provides complete flexibility: from highly controlled static placements to fully dynamic, responsive crowd simulations that can adapt to changing conditions in real-time.","title":"Overview"},{"location":"dynamic/#dynamic-icrowd-simulation-system-overview","text":"","title":"Dynamic iCrowd Simulation - System Overview"},{"location":"dynamic/#three-integrated-systems","text":"","title":"Three Integrated Systems"},{"location":"dynamic/#1-walkers-system-static-path-based-distribution","text":"Purpose : Create structured, lane-based crowd placements along defined paths Core Functionality : - Path-following agent distribution along curves and lanes - Controlled density with personal space management - Predictable, organized crowd patterns - Ideal for parades, guided flows, structured movement Key Components : Lanes, Walkers Curves, Noise controls, Personal Space settings","title":"1. Walkers System - Static Path-Based Distribution"},{"location":"dynamic/#2-city-system-static-urban-distribution","text":"Purpose : Environment-aware crowd placement for urban scenarios Core Functionality : - Terrain and infrastructure-based distribution (roads, sidewalks) - Activity-based agent behaviors (sleep, eat, work, leisure) - Collision-aware placement with environmental constraints - Urban-scale crowd simulation setup Key Components : ICity infrastructure, Activities system, Collision objects, Mask controls","title":"2. City System - Static Urban Distribution"},{"location":"dynamic/#3-fluid-system-dynamic-movement-control","text":"Purpose : Transform static distributions into living, responsive crowds Core Functionality : - Real-time movement simulation with physics-based behaviors - Multi-method control (path following, attraction, repulsion) - Dynamic response to environmental changes - Smooth, natural crowd flow and interactions Key Components : Motion engine, Flow Curves, Attract/Repel systems, Real-time controls","title":"3. Fluid System - Dynamic Movement Control"},{"location":"dynamic/#integrated-workflow","text":"","title":"Integrated Workflow"},{"location":"dynamic/#phase-1-static-setup","text":"Use Walkers for structured path-based distributions Use City for environment-aware urban placements Both systems output density maps and agent configurations","title":"Phase 1: Static Setup"},{"location":"dynamic/#phase-2-dynamic-activation","text":"Fluid system imports static distributions Applies motion behaviors and interactive controls Enables real-time crowd movement and responses","title":"Phase 2: Dynamic Activation"},{"location":"dynamic/#phase-3-runtime-control","text":"Adjust movement parameters in real-time Modify attractors/repellers during simulation Monitor and tweak crowd behaviors dynamically","title":"Phase 3: Runtime Control"},{"location":"dynamic/#system-relationships","text":"Static Systems (Walkers/City) \u2192 Fluid System \u2192 Dynamic Simulation \u2193 \u2193 Distribution Setup Movement Control \u2193 \u2193 Agent Placement Real-time Behavior","title":"System Relationships"},{"location":"dynamic/#unique-capabilities","text":"","title":"Unique Capabilities"},{"location":"dynamic/#walkers-system-specialization","text":"Precise lane control and flow direction Looping paths and structured formations Ideal for controlled crowd movements","title":"Walkers System Specialization"},{"location":"dynamic/#city-system-specialization","text":"Urban environment integration Activity-based behavior states Complex collision and space management","title":"City System Specialization"},{"location":"dynamic/#fluid-system-specialization","text":"Real-time dynamic control Multiple simultaneous movement methods Physics-based natural interactions","title":"Fluid System Specialization"},{"location":"dynamic/#use-case-scenarios","text":"Architectural Visualization : City (placement) \u2192 Fluid (movement) Event Planning : Walkers (structured flow) \u2192 Fluid (dynamic behavior) Urban Analysis : City (environment setup) \u2192 Fluid (traffic simulation) Entertainment : Combined use for complex crowd scenes This three-system approach provides complete flexibility: from highly controlled static placements to fully dynamic, responsive crowd simulations that can adapt to changing conditions in real-time.","title":"Use Case Scenarios"},{"location":"dynamic/city/","text":"City iCrowd Simulation System - User Documentation 1.0 System Overview The City Crowd Simulation System is a crowd generation tool for Blender that integrates seamlessly with the iCity addon . It allows users to populate urban environments with agents that navigate roads, sidewalks, and custom areas while avoiding obstacles. Key features include: Automatic integration with iCity road and sidewalk geometry Optional custom ground and colliders Support for default agents (idle, walk, run) or custom character collections Configurable population density, movement, and activity behaviors 2.0 Inputs 2.1 iCity Integration The system can automatically use iCity\u2019s road and sidewalk geometry. It also auto-detects colliders from the sidewalk. Inputs: Road: Main road geometry (required) SideWalk: Sidewalk geometry (required) Colliders: Automatically collected from sidewalks when using iCity 2.2 Custom Geometry Users can provide their own ground geometry and colliders: Ground: Mesh representing walkable surfaces Colliders: Collection of objects to avoid (buildings, obstacles, etc.) 3.0 Agents 3.1 Agent Types You can choose between: Default agents: Idle, walk, run animations included Custom agents: User-provided collection of characters 3.2 Agent Settings Agents Speed Scaler: Adjust the speed of agents (0.1\u20133.0, default 1.0) 4.0 Population Control 4.1 Density Settings Distance Min: Minimum spacing between agents (meters) Density Max: Maximum crowd density (0\u20131) Density Factor: Population multiplier (e.g., 0.5 = half, 2 = double) Seed: Randomize distribution for unique crowd arrangements 4.2 Mask Vertex Group: Limit agent spawning to specific areas 5.0 Movement and Simulation 5.1 Pathfinding Path Finding Details: Adjust precision vs performance Time Scale: Control simulation speed (1.0 = real-time) 5.2 Debug Tools Debug Movement: Visualize agent trajectories Debug Activity: Color-coded display of agent behaviors 6.0 Activity System Agents can perform four types of activities : Activity Purpose Inputs ADM_fun Entertainment Connect a collection of target objects (e.g., parks, theaters) ADM_sleep Rest Collection of seating objects or benches ADM_hunger Nutrition Collection of restaurant or food location objects ADM_balder Shelter Collection of covered or safe areas Usage: Create target objects or empties at relevant locations Group them into a collection Connect the collection to the corresponding activity socket Agents automatically navigate to the nearest target of that type 7.0 Recommended Workflow Choose either iCity integration or custom geometry . Set up agents (default or custom characters). Configure density and distribution settings. Set pathfinding and simulation speed . Define activities for agents if required. Use debug tools to verify agent movement and behaviors. 8.0 Optimization Tips Start with Density Max \u2264 0.5 for better performance Simplify colliders and ground geometry Use vertex group masks to limit agent count For large-scale crowds, prefer default agents or simplified proxies 9.0 Notes Agents automatically avoid obstacles detected from sidewalks in iCity mode. Custom colliders override automatic detection if provided. Custom agents must include at least idle, walk, and run animations for proper integration. Random seed ensures varied crowd patterns on each simulation run.","title":"City System"},{"location":"dynamic/city/#city-icrowd-simulation-system-user-documentation","text":"","title":"City iCrowd Simulation System - User Documentation"},{"location":"dynamic/city/#10-system-overview","text":"The City Crowd Simulation System is a crowd generation tool for Blender that integrates seamlessly with the iCity addon . It allows users to populate urban environments with agents that navigate roads, sidewalks, and custom areas while avoiding obstacles. Key features include: Automatic integration with iCity road and sidewalk geometry Optional custom ground and colliders Support for default agents (idle, walk, run) or custom character collections Configurable population density, movement, and activity behaviors","title":"1.0 System Overview"},{"location":"dynamic/city/#20-inputs","text":"","title":"2.0 Inputs"},{"location":"dynamic/city/#21-icity-integration","text":"The system can automatically use iCity\u2019s road and sidewalk geometry. It also auto-detects colliders from the sidewalk. Inputs: Road: Main road geometry (required) SideWalk: Sidewalk geometry (required) Colliders: Automatically collected from sidewalks when using iCity","title":"2.1 iCity Integration"},{"location":"dynamic/city/#22-custom-geometry","text":"Users can provide their own ground geometry and colliders: Ground: Mesh representing walkable surfaces Colliders: Collection of objects to avoid (buildings, obstacles, etc.)","title":"2.2 Custom Geometry"},{"location":"dynamic/city/#30-agents","text":"","title":"3.0 Agents"},{"location":"dynamic/city/#31-agent-types","text":"You can choose between: Default agents: Idle, walk, run animations included Custom agents: User-provided collection of characters","title":"3.1 Agent Types"},{"location":"dynamic/city/#32-agent-settings","text":"Agents Speed Scaler: Adjust the speed of agents (0.1\u20133.0, default 1.0)","title":"3.2 Agent Settings"},{"location":"dynamic/city/#40-population-control","text":"","title":"4.0 Population Control"},{"location":"dynamic/city/#41-density-settings","text":"Distance Min: Minimum spacing between agents (meters) Density Max: Maximum crowd density (0\u20131) Density Factor: Population multiplier (e.g., 0.5 = half, 2 = double) Seed: Randomize distribution for unique crowd arrangements","title":"4.1 Density Settings"},{"location":"dynamic/city/#42-mask","text":"Vertex Group: Limit agent spawning to specific areas","title":"4.2 Mask"},{"location":"dynamic/city/#50-movement-and-simulation","text":"","title":"5.0 Movement and Simulation"},{"location":"dynamic/city/#51-pathfinding","text":"Path Finding Details: Adjust precision vs performance Time Scale: Control simulation speed (1.0 = real-time)","title":"5.1 Pathfinding"},{"location":"dynamic/city/#52-debug-tools","text":"Debug Movement: Visualize agent trajectories Debug Activity: Color-coded display of agent behaviors","title":"5.2 Debug Tools"},{"location":"dynamic/city/#60-activity-system","text":"Agents can perform four types of activities : Activity Purpose Inputs ADM_fun Entertainment Connect a collection of target objects (e.g., parks, theaters) ADM_sleep Rest Collection of seating objects or benches ADM_hunger Nutrition Collection of restaurant or food location objects ADM_balder Shelter Collection of covered or safe areas Usage: Create target objects or empties at relevant locations Group them into a collection Connect the collection to the corresponding activity socket Agents automatically navigate to the nearest target of that type","title":"6.0 Activity System"},{"location":"dynamic/city/#70-recommended-workflow","text":"Choose either iCity integration or custom geometry . Set up agents (default or custom characters). Configure density and distribution settings. Set pathfinding and simulation speed . Define activities for agents if required. Use debug tools to verify agent movement and behaviors.","title":"7.0 Recommended Workflow"},{"location":"dynamic/city/#80-optimization-tips","text":"Start with Density Max \u2264 0.5 for better performance Simplify colliders and ground geometry Use vertex group masks to limit agent count For large-scale crowds, prefer default agents or simplified proxies","title":"8.0 Optimization Tips"},{"location":"dynamic/city/#90-notes","text":"Agents automatically avoid obstacles detected from sidewalks in iCity mode. Custom colliders override automatic detection if provided. Custom agents must include at least idle, walk, and run animations for proper integration. Random seed ensures varied crowd patterns on each simulation run.","title":"9.0 Notes"},{"location":"dynamic/fluid/","text":"Fluid iCrowd Simulation System - User Documentation Overview The Fluid System is a dynamic crowd simulation tool that transforms static crowd distributions into living, moving populations. It takes pre-made density layouts from other systems and brings them to life with realistic movement behaviors. Core Components Input Module Purpose : Import and process static crowd distributions Parameters : - Density Source - Terrain: Base surface for crowd placement - Distribution Type: Method of agent distribution - Crowds Objects: Reference objects for density calculation - Input Density object/objects: Pre-configured density setups Distribution Controls Distance Min: Minimum spacing between agents Density Max: Maximum agent concentration Seed: Randomization seed for variation Mask Vertex Group: Vertex-based placement restrictions Animation Setup Agent animation configurations and behaviors Motion Engine Purpose : Control agent movement characteristics and physics Settings : - Walk Speed : Normal movement velocity (m/s) - Run Speed : Fast movement velocity (m/s) - Max Speed : Velocity cap for all movements (m/s) - Relax Iterations : Physics smoothing passes for natural movement Movement Control Systems Purpose : Direct agent flow and behavior patterns Path-Based Movement Flow Curve : Single guiding path for agent direction Flow Curves : Multiple path networks for complex routing Behavior: Agents follow curve direction and flow Attraction System Attract : Enable/disable attraction behavior Attracters : Target objects that pull agents toward them Behavior: Agents naturally move toward attractive points Repulsion System Repel : Enable/disable repulsion behavior Repelers : Objects that agents avoid Behavior: Agents maintain distance from repulsive elements Workflow Phase 1: Distribution Setup Create static crowd layout using Walkers or City systems Export density configuration and agent placements Phase 2: Fluid System Integration Import static distribution into Fluid system Configure density parameters and terrain matching Set up animation behaviors for agents Phase 3: Movement Control Path-based Flow : Add curves to guide agent direction Attraction Points : Place objects to pull agents toward goals Repulsion Zones : Set up barriers and avoidance areas Motion Tuning : Adjust speeds and physics for realism Phase 4: Simulation Activate real-time movement simulation Monitor agent interactions and flow patterns Adjust parameters dynamically during runtime Use Cases Urban Scenarios Pedestrian flows through city streets Crowd movement in public squares Emergency evacuation simulations Entertainment Applications Animated crowds in films/games Event planning and crowd management Architectural visualization with living populations Technical Applications Traffic flow analysis Space utilization studies Behavioral pattern research Key Features Real-time Control : Adjust parameters while simulation runs Multi-method Movement : Combine paths, attraction, and repulsion Physics-based : Natural collision avoidance and flow dynamics Scalable : Handle from small groups to massive crowds Interoperable : Works with various static distribution systems","title":"Fluid System"},{"location":"dynamic/fluid/#fluid-icrowd-simulation-system-user-documentation","text":"","title":"Fluid iCrowd Simulation System - User Documentation"},{"location":"dynamic/fluid/#overview","text":"The Fluid System is a dynamic crowd simulation tool that transforms static crowd distributions into living, moving populations. It takes pre-made density layouts from other systems and brings them to life with realistic movement behaviors.","title":"Overview"},{"location":"dynamic/fluid/#core-components","text":"","title":"Core Components"},{"location":"dynamic/fluid/#input-module","text":"Purpose : Import and process static crowd distributions Parameters : - Density Source - Terrain: Base surface for crowd placement - Distribution Type: Method of agent distribution - Crowds Objects: Reference objects for density calculation - Input Density object/objects: Pre-configured density setups Distribution Controls Distance Min: Minimum spacing between agents Density Max: Maximum agent concentration Seed: Randomization seed for variation Mask Vertex Group: Vertex-based placement restrictions Animation Setup Agent animation configurations and behaviors","title":"Input Module"},{"location":"dynamic/fluid/#motion-engine","text":"Purpose : Control agent movement characteristics and physics Settings : - Walk Speed : Normal movement velocity (m/s) - Run Speed : Fast movement velocity (m/s) - Max Speed : Velocity cap for all movements (m/s) - Relax Iterations : Physics smoothing passes for natural movement","title":"Motion Engine"},{"location":"dynamic/fluid/#movement-control-systems","text":"Purpose : Direct agent flow and behavior patterns","title":"Movement Control Systems"},{"location":"dynamic/fluid/#path-based-movement","text":"Flow Curve : Single guiding path for agent direction Flow Curves : Multiple path networks for complex routing Behavior: Agents follow curve direction and flow","title":"Path-Based Movement"},{"location":"dynamic/fluid/#attraction-system","text":"Attract : Enable/disable attraction behavior Attracters : Target objects that pull agents toward them Behavior: Agents naturally move toward attractive points","title":"Attraction System"},{"location":"dynamic/fluid/#repulsion-system","text":"Repel : Enable/disable repulsion behavior Repelers : Objects that agents avoid Behavior: Agents maintain distance from repulsive elements","title":"Repulsion System"},{"location":"dynamic/fluid/#workflow","text":"","title":"Workflow"},{"location":"dynamic/fluid/#phase-1-distribution-setup","text":"Create static crowd layout using Walkers or City systems Export density configuration and agent placements","title":"Phase 1: Distribution Setup"},{"location":"dynamic/fluid/#phase-2-fluid-system-integration","text":"Import static distribution into Fluid system Configure density parameters and terrain matching Set up animation behaviors for agents","title":"Phase 2: Fluid System Integration"},{"location":"dynamic/fluid/#phase-3-movement-control","text":"Path-based Flow : Add curves to guide agent direction Attraction Points : Place objects to pull agents toward goals Repulsion Zones : Set up barriers and avoidance areas Motion Tuning : Adjust speeds and physics for realism","title":"Phase 3: Movement Control"},{"location":"dynamic/fluid/#phase-4-simulation","text":"Activate real-time movement simulation Monitor agent interactions and flow patterns Adjust parameters dynamically during runtime","title":"Phase 4: Simulation"},{"location":"dynamic/fluid/#use-cases","text":"","title":"Use Cases"},{"location":"dynamic/fluid/#urban-scenarios","text":"Pedestrian flows through city streets Crowd movement in public squares Emergency evacuation simulations","title":"Urban Scenarios"},{"location":"dynamic/fluid/#entertainment-applications","text":"Animated crowds in films/games Event planning and crowd management Architectural visualization with living populations","title":"Entertainment Applications"},{"location":"dynamic/fluid/#technical-applications","text":"Traffic flow analysis Space utilization studies Behavioral pattern research","title":"Technical Applications"},{"location":"dynamic/fluid/#key-features","text":"Real-time Control : Adjust parameters while simulation runs Multi-method Movement : Combine paths, attraction, and repulsion Physics-based : Natural collision avoidance and flow dynamics Scalable : Handle from small groups to massive crowds Interoperable : Works with various static distribution systems","title":"Key Features"},{"location":"dynamic/walkers/","text":"Walkers iCrowd Simulation System - User Documentation 1.0 System Overview The Walkers Path System is a curve-based pedestrian animation tool that generates animated characters moving along user-defined paths. The system creates natural movement patterns around drawn curves with configurable lane behavior, density, and motion parameters. 2.0 Quick Start 2.1 Basic Setup Create a curve in your scene Connect the curve to \"Walkers Curve\" input Set Agent Object or Collection for characters Adjust Count for desired number of walkers Play timeline to activate animation 3.0 Input Configuration 3.1 Primary Inputs Terrain (Optional) - Purpose: Ground surface for elevation matching - Usage: Connect terrain mesh for height alignment Input Type - Purpose: Determines how paths are generated - Options: Single curve or curve collection Walkers Curves/Walkers Curve - Purpose: Path definition for walker movement - Usage: Connect B\u00e9zier curve or curve collection 4.0 Agent Configuration 4.1 Agent Assignment Object - Purpose: Single character object to duplicate - Usage: Connect a mesh object with walk animation Collection - Purpose: Multiple character variations - Usage: Connect collection of character objects 4.2 Path Parameters Lanes - Purpose: Number of parallel walking paths - Effect: Creates multi-lane pedestrian flow - Range: 1-8 (typical urban sidewalk capacity) Count - Purpose: Total number of walkers on path - Effect: Controls pedestrian density - Recommendation: Start with 10-20 for testing Direction - Purpose: Movement direction along curve - Options: Forward, Reverse, Bidirectional Loop Type - Purpose: Path cycling behavior - Options: - Single Pass: One-time traversal - Loop: Continuous circulation - Ping-Pong: Forward/reverse alternation 5.0 Motion Control 5.1 Noise Parameters Power - Purpose: Intensity of path variation - Effect: Creates natural path deviations - Range: 0.0 (exact path) to 1.0 (maximum variation) Offset - Purpose: Lateral position variation - Effect: Random lane positioning - Usage: Creates organic spacing Scale - Purpose: Spatial frequency of noise - Effect: Controls deviation pattern scale 5.2 Speed Management Speed - Purpose: Base movement velocity - Units: Blender units per second - Typical: 1.0-2.0 for walking speed 6.0 Density & Spacing 6.1 Density Control Density - Purpose: Overall walker concentration - Effect: Multiplier for Count parameter - Range: 0.0 (none) to 2.0 (double density) Randomness - Purpose: Distribution variation - Effect: Irregular spacing between walkers - Usage: Avoids robotic uniformity Seed - Purpose: Randomization control - Effect: Unique distribution patterns 6.2 Personal Space Configuration Min/Max Space - Purpose: Inter-walker distance constraints - Min: Minimum allowed distance (avoid collision) - Max: Maximum allowed distance (maintain group cohesion) Seed - Purpose: Personal space randomization - Effect: Natural distance variations 7.0 Implementation Guide 7.1 Basic Workflow 1. Create and position B\u00e9zier curve for desired path 2. Connect curve to \"Walkers Curve\" socket 3. Assign character object/collection to \"Object\" or \"Collection\" 4. Set Count to desired number of walkers (10-50 typical) 5. Configure Lanes for path width (2-4 for sidewalks) 6. Adjust Speed for realistic movement (1.2-1.8) 7. Enable timeline playback to activate animation 7.2 Advanced Configurations Multi-lane Sidewalk - Lanes: 3 - Count: 25 - Direction: Bidirectional - Loop Type: Loop - Power: 0.3 (subtle variation) Single-file Path - Lanes: 1 - Count: 15 - Direction: Forward - Loop Type: Single Pass - Power: 0.1 (minimal deviation) 8.0 Animation Integration 8.1 Character Requirements Walk cycle animation required Proper armature rigging for natural movement Scale matching to scene proportions 8.2 Motion Blending System automatically matches animation speed to path velocity Supports walk/run cycle blending based on speed parameter Root motion alignment with path curvature 9.0 Performance Optimization 9.1 Efficiency Guidelines Use simplified character meshes for large counts Limit Count to scene requirements (typically < 100) Use moderate Power values (0.2-0.5) for balance Consider instancing for identical characters 9.2 Quality Settings High Quality: - Count: 50-100 - Power: 0.3-0.6 - High-detail characters Performance Mode: - Count: 10-30 - Power: 0.1-0.3 - Low-poly characters 10.0 Use Cases 10.1 Urban Scenarios Sidewalk pedestrian flows Park pathway circulation Shopping district foot traffic Event venue entry/exit flows 10.2 Architectural Visualization Building entrance approaches Plaza and courtyard movement Stairway and ramp circulation Queue simulation for facilities 11.0 Troubleshooting 11.1 Common Issues Walkers Not Moving - Verify curve connection to correct socket - Check timeline is playing - Validate character objects have animations Uneven Spacing - Adjust Personal Space Min/Max values - Reduce Randomness parameter - Check curve resolution and length Unnatural Movement - Reduce Power parameter for straighter paths - Adjust Speed to match animation cycle - Verify proper character scaling 12.0 Technical Notes 12.1 Curve Requirements Use B\u00e9zier curves for smooth paths Ensure adequate curve resolution Avoid sharp angles for natural movement Closed curves work well for looped paths 12.2 System Integration Compatible with main crowd system Can be used alongside area-based crowds Supports hybrid approaches (path + free movement) Documentation Version: 1.0 | System: Walkers Path Module","title":"Walkers System"},{"location":"dynamic/walkers/#walkers-icrowd-simulation-system-user-documentation","text":"","title":"Walkers iCrowd Simulation System - User Documentation"},{"location":"dynamic/walkers/#10-system-overview","text":"The Walkers Path System is a curve-based pedestrian animation tool that generates animated characters moving along user-defined paths. The system creates natural movement patterns around drawn curves with configurable lane behavior, density, and motion parameters.","title":"1.0 System Overview"},{"location":"dynamic/walkers/#20-quick-start","text":"","title":"2.0 Quick Start"},{"location":"dynamic/walkers/#21-basic-setup","text":"Create a curve in your scene Connect the curve to \"Walkers Curve\" input Set Agent Object or Collection for characters Adjust Count for desired number of walkers Play timeline to activate animation","title":"2.1 Basic Setup"},{"location":"dynamic/walkers/#30-input-configuration","text":"","title":"3.0 Input Configuration"},{"location":"dynamic/walkers/#31-primary-inputs","text":"Terrain (Optional) - Purpose: Ground surface for elevation matching - Usage: Connect terrain mesh for height alignment Input Type - Purpose: Determines how paths are generated - Options: Single curve or curve collection Walkers Curves/Walkers Curve - Purpose: Path definition for walker movement - Usage: Connect B\u00e9zier curve or curve collection","title":"3.1 Primary Inputs"},{"location":"dynamic/walkers/#40-agent-configuration","text":"","title":"4.0 Agent Configuration"},{"location":"dynamic/walkers/#41-agent-assignment","text":"Object - Purpose: Single character object to duplicate - Usage: Connect a mesh object with walk animation Collection - Purpose: Multiple character variations - Usage: Connect collection of character objects","title":"4.1 Agent Assignment"},{"location":"dynamic/walkers/#42-path-parameters","text":"Lanes - Purpose: Number of parallel walking paths - Effect: Creates multi-lane pedestrian flow - Range: 1-8 (typical urban sidewalk capacity) Count - Purpose: Total number of walkers on path - Effect: Controls pedestrian density - Recommendation: Start with 10-20 for testing Direction - Purpose: Movement direction along curve - Options: Forward, Reverse, Bidirectional Loop Type - Purpose: Path cycling behavior - Options: - Single Pass: One-time traversal - Loop: Continuous circulation - Ping-Pong: Forward/reverse alternation","title":"4.2 Path Parameters"},{"location":"dynamic/walkers/#50-motion-control","text":"","title":"5.0 Motion Control"},{"location":"dynamic/walkers/#51-noise-parameters","text":"Power - Purpose: Intensity of path variation - Effect: Creates natural path deviations - Range: 0.0 (exact path) to 1.0 (maximum variation) Offset - Purpose: Lateral position variation - Effect: Random lane positioning - Usage: Creates organic spacing Scale - Purpose: Spatial frequency of noise - Effect: Controls deviation pattern scale","title":"5.1 Noise Parameters"},{"location":"dynamic/walkers/#52-speed-management","text":"Speed - Purpose: Base movement velocity - Units: Blender units per second - Typical: 1.0-2.0 for walking speed","title":"5.2 Speed Management"},{"location":"dynamic/walkers/#60-density-spacing","text":"","title":"6.0 Density &amp; Spacing"},{"location":"dynamic/walkers/#61-density-control","text":"Density - Purpose: Overall walker concentration - Effect: Multiplier for Count parameter - Range: 0.0 (none) to 2.0 (double density) Randomness - Purpose: Distribution variation - Effect: Irregular spacing between walkers - Usage: Avoids robotic uniformity Seed - Purpose: Randomization control - Effect: Unique distribution patterns","title":"6.1 Density Control"},{"location":"dynamic/walkers/#62-personal-space-configuration","text":"Min/Max Space - Purpose: Inter-walker distance constraints - Min: Minimum allowed distance (avoid collision) - Max: Maximum allowed distance (maintain group cohesion) Seed - Purpose: Personal space randomization - Effect: Natural distance variations","title":"6.2 Personal Space Configuration"},{"location":"dynamic/walkers/#70-implementation-guide","text":"","title":"7.0 Implementation Guide"},{"location":"dynamic/walkers/#71-basic-workflow","text":"1. Create and position B\u00e9zier curve for desired path 2. Connect curve to \"Walkers Curve\" socket 3. Assign character object/collection to \"Object\" or \"Collection\" 4. Set Count to desired number of walkers (10-50 typical) 5. Configure Lanes for path width (2-4 for sidewalks) 6. Adjust Speed for realistic movement (1.2-1.8) 7. Enable timeline playback to activate animation","title":"7.1 Basic Workflow"},{"location":"dynamic/walkers/#72-advanced-configurations","text":"Multi-lane Sidewalk - Lanes: 3 - Count: 25 - Direction: Bidirectional - Loop Type: Loop - Power: 0.3 (subtle variation) Single-file Path - Lanes: 1 - Count: 15 - Direction: Forward - Loop Type: Single Pass - Power: 0.1 (minimal deviation)","title":"7.2 Advanced Configurations"},{"location":"dynamic/walkers/#80-animation-integration","text":"","title":"8.0 Animation Integration"},{"location":"dynamic/walkers/#81-character-requirements","text":"Walk cycle animation required Proper armature rigging for natural movement Scale matching to scene proportions","title":"8.1 Character Requirements"},{"location":"dynamic/walkers/#82-motion-blending","text":"System automatically matches animation speed to path velocity Supports walk/run cycle blending based on speed parameter Root motion alignment with path curvature","title":"8.2 Motion Blending"},{"location":"dynamic/walkers/#90-performance-optimization","text":"","title":"9.0 Performance Optimization"},{"location":"dynamic/walkers/#91-efficiency-guidelines","text":"Use simplified character meshes for large counts Limit Count to scene requirements (typically < 100) Use moderate Power values (0.2-0.5) for balance Consider instancing for identical characters","title":"9.1 Efficiency Guidelines"},{"location":"dynamic/walkers/#92-quality-settings","text":"High Quality: - Count: 50-100 - Power: 0.3-0.6 - High-detail characters Performance Mode: - Count: 10-30 - Power: 0.1-0.3 - Low-poly characters","title":"9.2 Quality Settings"},{"location":"dynamic/walkers/#100-use-cases","text":"","title":"10.0 Use Cases"},{"location":"dynamic/walkers/#101-urban-scenarios","text":"Sidewalk pedestrian flows Park pathway circulation Shopping district foot traffic Event venue entry/exit flows","title":"10.1 Urban Scenarios"},{"location":"dynamic/walkers/#102-architectural-visualization","text":"Building entrance approaches Plaza and courtyard movement Stairway and ramp circulation Queue simulation for facilities","title":"10.2 Architectural Visualization"},{"location":"dynamic/walkers/#110-troubleshooting","text":"","title":"11.0 Troubleshooting"},{"location":"dynamic/walkers/#111-common-issues","text":"Walkers Not Moving - Verify curve connection to correct socket - Check timeline is playing - Validate character objects have animations Uneven Spacing - Adjust Personal Space Min/Max values - Reduce Randomness parameter - Check curve resolution and length Unnatural Movement - Reduce Power parameter for straighter paths - Adjust Speed to match animation cycle - Verify proper character scaling","title":"11.1 Common Issues"},{"location":"dynamic/walkers/#120-technical-notes","text":"","title":"12.0 Technical Notes"},{"location":"dynamic/walkers/#121-curve-requirements","text":"Use B\u00e9zier curves for smooth paths Ensure adequate curve resolution Avoid sharp angles for natural movement Closed curves work well for looped paths","title":"12.1 Curve Requirements"},{"location":"dynamic/walkers/#122-system-integration","text":"Compatible with main crowd system Can be used alongside area-based crowds Supports hybrid approaches (path + free movement) Documentation Version: 1.0 | System: Walkers Path Module","title":"12.2 System Integration"},{"location":"static/","text":"iCrowds Stadium System - Quick Overview \ud83c\udfdf\ufe0f Purpose Specialized tool for organized seating/venue crowds. Perfect for theaters, stadiums, conferences - any structured seating arrangements. \u26a1 4 Input Methods On Face : Grid-based (rows/columns) on any surface On Instance : Place on existing Geometry Nodes instances (chairs) On Collection : Distribute across scene objects On Vertex : Precise vertex-based placement \ud83c\udfaf Key Features Fill Control : Adjust occupancy density (0-100%) Weight Painting : Visual density control Rotation Types : Multiple alignment options Local Space Controls : Perfect object alignment Grid Precision : Exact row/column layouts \ud83d\ude80 Best For Theater/stadium audiences Conference/classroom seating Organized venue layouts Precise crowd formations \ud83d\udca1 Pro Tip Start with On Face method using a simple plane - fastest way to create custom seating grids. Combine with other scatter systems for surrounding areas. Perfect for creating organized crowds that other scatter systems can't handle.","title":"Overview"},{"location":"static/#icrowds-stadium-system-quick-overview","text":"","title":"iCrowds Stadium System - Quick Overview"},{"location":"static/#purpose","text":"Specialized tool for organized seating/venue crowds. Perfect for theaters, stadiums, conferences - any structured seating arrangements.","title":"\ud83c\udfdf\ufe0f Purpose"},{"location":"static/#4-input-methods","text":"On Face : Grid-based (rows/columns) on any surface On Instance : Place on existing Geometry Nodes instances (chairs) On Collection : Distribute across scene objects On Vertex : Precise vertex-based placement","title":"\u26a1 4 Input Methods"},{"location":"static/#key-features","text":"Fill Control : Adjust occupancy density (0-100%) Weight Painting : Visual density control Rotation Types : Multiple alignment options Local Space Controls : Perfect object alignment Grid Precision : Exact row/column layouts","title":"\ud83c\udfaf Key Features"},{"location":"static/#best-for","text":"Theater/stadium audiences Conference/classroom seating Organized venue layouts Precise crowd formations","title":"\ud83d\ude80 Best For"},{"location":"static/#pro-tip","text":"Start with On Face method using a simple plane - fastest way to create custom seating grids. Combine with other scatter systems for surrounding areas. Perfect for creating organized crowds that other scatter systems can't handle.","title":"\ud83d\udca1 Pro Tip"},{"location":"static/scatter/","text":"iCrowds Static Scatter Systems Overview Quick Reference Guide \ud83c\udfde\ufe0f Static On Ground Best for : Terrain-based distributions, natural environments, large-scale scattering Core Function : Scatter agents across surfaces with controlled density and grouping options Key Features : - Dual Distribution : Choose between individual agents or clustered groups - Advanced Masking : Vertex groups and spherical masks for precise placement control - Natural Spacing : Physics-based personal space algorithms - Scale Variations : Size diversity for organic results Ideal Use Cases : - Populating landscapes with vegetation/rocks - Crowds in open spaces (parks, plazas) - Large-scale environment population - Urban street scenes with pedestrians - Natural ecosystem simulations \ud83d\udee3\ufe0f Static On Curve Best for : Path-based distributions, linear formations, radius-controlled density Core Function : Distribute agents along curves with intelligent radius-driven density Key Features : - Radius-Driven Density : Use Alt+S curve scaling to control agent concentration - Adaptive Spacing : Automatic adjustment based on curve width variations - Path Following : Natural orientation along curve direction - Dual Methods : Count-based or density-per-length placement Ideal Use Cases : - Pedestrians along sidewalks/paths - Vehicles on roads - Queue lines and procession formations - Street vendors along market paths - Parade participants along routes \ud83d\udccd Static On Vertex Best for : Precision placement, architectural layouts, exact positioning Core Function : Place agents exactly on mesh vertices with controlled variation Key Features : - Vertex-Level Precision : Each agent placed on specific mesh vertices - Vertex Group Masking : Exact control over placement patterns - Topology-Aware : Distribution follows mesh edge flow - Structured Variation : Natural randomness while maintaining layout Ideal Use Cases : - Audience seating in theaters/venues - Furniture placement in architectural plans - Organized formations and precise layouts - Data visualization with exact positioning - Exhibition booth arrangements - Classroom or conference seating System Selection Matrix Scenario Recommended System Why Natural landscapes \ud83c\udfde\ufe0f On Ground Best for organic, terrain-following distributions Paths and roads \ud83d\udee3\ufe0f On Curve Perfect for linear distributions with width variations Architectural precision \ud83d\udccd On Vertex Exact placement on predefined points Large crowds \ud83c\udfde\ufe0f On Ground Handles massive distributions efficiently Queue lines \ud83d\udee3\ufe0f On Curve Natural flow along curves Theater/venue seating \ud83d\udccd On Vertex Precise seat-by-seat placement Random scattering \ud83c\udfde\ufe0f On Ground Advanced randomization options Patterned layouts \ud83d\udccd On Vertex Vertex groups for exact patterns Variable density areas \ud83d\udee3\ufe0f On Curve Radius control for density gradients Urban planning \ud83c\udfde\ufe0f On Ground + \ud83d\udee3\ufe0f On Curve Combine for complex city scenes Workflow Recommendations Start with On Ground when : You need quick, large-scale population Working with natural terrains Don't need precise positioning Want maximum flexibility Choose On Curve when : Distribution follows paths or roads You need width-based density control Creating linear formations Working with existing curve networks Use On Vertex when : Precision placement is critical You have predefined layout points Working with architectural plans Need exact pattern control Pro Tips Combine Systems : Use On Vertex for key positions + On Ground for fill population On Curve for main paths + On Ground for surrounding areas Layer systems for complex, realistic distributions Performance Considerations : On Ground : Best for large-scale, performance-heavy scenes On Curve : Efficient for linear distributions On Vertex : Most precise but vertex-count dependent Transition to Animation : All static systems prepare perfect starting positions for the Fluid System dynamic animation! Choose your scatter system based on placement precision needs and the natural flow of your scene!","title":"Overview"},{"location":"static/scatter/#icrowds-static-scatter-systems-overview","text":"","title":"iCrowds Static Scatter Systems Overview"},{"location":"static/scatter/#quick-reference-guide","text":"","title":"Quick Reference Guide"},{"location":"static/scatter/#static-on-ground","text":"Best for : Terrain-based distributions, natural environments, large-scale scattering Core Function : Scatter agents across surfaces with controlled density and grouping options Key Features : - Dual Distribution : Choose between individual agents or clustered groups - Advanced Masking : Vertex groups and spherical masks for precise placement control - Natural Spacing : Physics-based personal space algorithms - Scale Variations : Size diversity for organic results Ideal Use Cases : - Populating landscapes with vegetation/rocks - Crowds in open spaces (parks, plazas) - Large-scale environment population - Urban street scenes with pedestrians - Natural ecosystem simulations","title":"\ud83c\udfde\ufe0f Static On Ground"},{"location":"static/scatter/#static-on-curve","text":"Best for : Path-based distributions, linear formations, radius-controlled density Core Function : Distribute agents along curves with intelligent radius-driven density Key Features : - Radius-Driven Density : Use Alt+S curve scaling to control agent concentration - Adaptive Spacing : Automatic adjustment based on curve width variations - Path Following : Natural orientation along curve direction - Dual Methods : Count-based or density-per-length placement Ideal Use Cases : - Pedestrians along sidewalks/paths - Vehicles on roads - Queue lines and procession formations - Street vendors along market paths - Parade participants along routes","title":"\ud83d\udee3\ufe0f Static On Curve"},{"location":"static/scatter/#static-on-vertex","text":"Best for : Precision placement, architectural layouts, exact positioning Core Function : Place agents exactly on mesh vertices with controlled variation Key Features : - Vertex-Level Precision : Each agent placed on specific mesh vertices - Vertex Group Masking : Exact control over placement patterns - Topology-Aware : Distribution follows mesh edge flow - Structured Variation : Natural randomness while maintaining layout Ideal Use Cases : - Audience seating in theaters/venues - Furniture placement in architectural plans - Organized formations and precise layouts - Data visualization with exact positioning - Exhibition booth arrangements - Classroom or conference seating","title":"\ud83d\udccd Static On Vertex"},{"location":"static/scatter/#system-selection-matrix","text":"Scenario Recommended System Why Natural landscapes \ud83c\udfde\ufe0f On Ground Best for organic, terrain-following distributions Paths and roads \ud83d\udee3\ufe0f On Curve Perfect for linear distributions with width variations Architectural precision \ud83d\udccd On Vertex Exact placement on predefined points Large crowds \ud83c\udfde\ufe0f On Ground Handles massive distributions efficiently Queue lines \ud83d\udee3\ufe0f On Curve Natural flow along curves Theater/venue seating \ud83d\udccd On Vertex Precise seat-by-seat placement Random scattering \ud83c\udfde\ufe0f On Ground Advanced randomization options Patterned layouts \ud83d\udccd On Vertex Vertex groups for exact patterns Variable density areas \ud83d\udee3\ufe0f On Curve Radius control for density gradients Urban planning \ud83c\udfde\ufe0f On Ground + \ud83d\udee3\ufe0f On Curve Combine for complex city scenes","title":"System Selection Matrix"},{"location":"static/scatter/#workflow-recommendations","text":"","title":"Workflow Recommendations"},{"location":"static/scatter/#start-with-on-ground-when","text":"You need quick, large-scale population Working with natural terrains Don't need precise positioning Want maximum flexibility","title":"Start with On Ground when:"},{"location":"static/scatter/#choose-on-curve-when","text":"Distribution follows paths or roads You need width-based density control Creating linear formations Working with existing curve networks","title":"Choose On Curve when:"},{"location":"static/scatter/#use-on-vertex-when","text":"Precision placement is critical You have predefined layout points Working with architectural plans Need exact pattern control","title":"Use On Vertex when:"},{"location":"static/scatter/#pro-tips","text":"","title":"Pro Tips"},{"location":"static/scatter/#combine-systems","text":"Use On Vertex for key positions + On Ground for fill population On Curve for main paths + On Ground for surrounding areas Layer systems for complex, realistic distributions","title":"Combine Systems:"},{"location":"static/scatter/#performance-considerations","text":"On Ground : Best for large-scale, performance-heavy scenes On Curve : Efficient for linear distributions On Vertex : Most precise but vertex-count dependent","title":"Performance Considerations:"},{"location":"static/scatter/#transition-to-animation","text":"All static systems prepare perfect starting positions for the Fluid System dynamic animation! Choose your scatter system based on placement precision needs and the natural flow of your scene!","title":"Transition to Animation:"},{"location":"static/stadium/","text":"iCrowds Static Stadium Documentation Overview The Static Stadium system is a specialized crowd distribution tool designed for structured seating arrangements and organized formations. It provides multiple input methods for precise agent placement on seating surfaces, instance objects, or predefined points, making it ideal for venues, theaters, and any scenario requiring organized crowd layouts. Core Components Inputs Purpose : Define agent sources and distribution methods Parameters : - Agents : Source objects or collections for placement - Agent Input Type : Switch between Object or Collection input methods - Input Type : Primary distribution method selector Distribution Methods On Face Distribution Purpose : Place agents in organized grid patterns on surface faces Parameters : - Face Uv Object : Target face object with UV mapping (recommended: scaled/rotated plane) - Count X : Number of agents along the X-axis (columns) - Count Y : Number of agents along the Y-axis (rows) Best for: Custom seating layouts, flexible grid arrangements On Instance Distribution Purpose : Place agents on existing geometry nodes instances Parameters : - Geo_Nodes Object : Geometry nodes object with instances output - Perfect for: Chair instances, predefined seating arrangements On Collection Objects Purpose : Distribute agents across objects in a collection Parameters : - On Collection : Target collection containing placement objects - Ideal for: Existing scene objects as placement points On Vertex Distribution Purpose : Precise placement on mesh vertices with advanced controls Parameters : - On Vertix : Target mesh for vertex-based placement - Fill Factor : Density control (0.0-1.0) - Weight Paint Fill : Use vertex groups/weight painting for density variation Settings Panel Purpose : Fine-tune agent orientation and variation Rotation Orientation Control : - Rotation Type : Method for agent rotation alignment - Options: Face normal, object direction, custom vectors Random Variation Controls : - Mix Factor : Blend between perfect alignment and randomness - Rotation Min : Minimum random rotation offset - Rotation Max : Maximum random rotation offset - Rotation Seed : Randomization control for reproducible results At Object Panel Purpose : Advanced instance transformation controls Parameters : - At Object : Target object for placement - Randomize : Enable randomization features Transformation Controls Instance Translation : - Offset : Position offset from base placement - Translation Local Space : Use local coordinates for offsets Instance Rotation : - Rotation Local Space : Local coordinate rotation - Advanced orientation adjustments Instance Scale : - Scale Local Space : Local coordinate scaling - Size variations within the formation Workflow Phase 1: Input Method Selection Choose based on your scene setup: Option A: On Face Method 1. Create a plane and scale/rotate to fit seating area 2. Ensure proper UV mapping on the face 3. Set Count X/Y for grid dimensions Option B: On Instance Method 1. Use Geometry Nodes to create chair/seat instances 2. Reference the GN object in the system 3. Agents automatically place on each instance Option C: On Collection Objects 1. Gather placement objects into a collection 2. Reference the collection in the system 3. Agents distribute across all collection objects Option D: On Vertex Method 1. Use mesh with vertex layout matching seating 2. Apply vertex groups/weight painting for density control 3. Adjust Fill Factor for overall density Phase 2: Agent Configuration Select agent objects or collections Choose Object or Collection input type Set up agent properties and variations Phase 3: Placement Refinement Adjust Rotation Type for proper orientation Use Random settings for natural variation Fine-tune Mix Factor for balance between order and randomness Phase 4: Advanced Transformations Use At Object panel for specific placement adjustments Apply offsets and local transformations Adjust instance scaling for size variations Use Cases Venue Seating Theater audiences Stadium crowds Concert seating arrangements Lecture hall populations Event Planning Conference seating layouts Wedding ceremony arrangements Exhibition booth assignments Ceremonial formations Architectural Visualization Building occupancy simulations Space planning with populated areas Venue capacity testing Entertainment Production Film/TV crowd scenes in venues Game level population Virtual event planning Advanced Techniques Multi-Method Workflow Combine On Face for main seating + On Vertex for VIP sections Use On Instance for fixed seating + On Collection for special areas Layer methods for complex venue layouts Weight Painting for Density Paint high-density areas for premium seating Create sparse areas for aisles and walkways Animate weight maps for dynamic crowd changes Geometry Nodes Integration Create sophisticated instance patterns with GN Use attribute-based variations for realistic seating Combine with scatter systems for hybrid approaches Key Features Multiple Input Methods : Flexible placement options for any scenario Precision Grid Control : Exact row/column arrangements with On Face Instance Awareness : Perfect alignment with existing geometry Vertex Group Integration : Advanced density control through weight painting Transformation Flexibility : Local/global space controls for perfect alignment Natural Variation : Controlled randomness for organic-looking crowds Pro Tips Face Method Best Practices Use a single quad face for best results Ensure proper UV scaling to match venue proportions Adjust Count X/Y to match actual seating dimensions Instance Method Optimization Pre-generate chair instances with Geometry Nodes Use instances with consistent orientation for uniform results Combine with vertex groups for section-based variations Vertex Method Advanced Use Create vertex groups for different ticket sections Use weight painting for gradual density transitions Animate vertex weights for crowd movement simulations The Static Stadium system provides venue-specific crowd distribution with architectural precision, offering multiple workflow options to match any seating arrangement scenario from simple theaters to complex stadium layouts.","title":"Stadium"},{"location":"static/stadium/#icrowds-static-stadium-documentation","text":"","title":"iCrowds Static Stadium Documentation"},{"location":"static/stadium/#overview","text":"The Static Stadium system is a specialized crowd distribution tool designed for structured seating arrangements and organized formations. It provides multiple input methods for precise agent placement on seating surfaces, instance objects, or predefined points, making it ideal for venues, theaters, and any scenario requiring organized crowd layouts.","title":"Overview"},{"location":"static/stadium/#core-components","text":"","title":"Core Components"},{"location":"static/stadium/#inputs","text":"Purpose : Define agent sources and distribution methods Parameters : - Agents : Source objects or collections for placement - Agent Input Type : Switch between Object or Collection input methods - Input Type : Primary distribution method selector","title":"Inputs"},{"location":"static/stadium/#distribution-methods","text":"","title":"Distribution Methods"},{"location":"static/stadium/#on-face-distribution","text":"Purpose : Place agents in organized grid patterns on surface faces Parameters : - Face Uv Object : Target face object with UV mapping (recommended: scaled/rotated plane) - Count X : Number of agents along the X-axis (columns) - Count Y : Number of agents along the Y-axis (rows) Best for: Custom seating layouts, flexible grid arrangements","title":"On Face Distribution"},{"location":"static/stadium/#on-instance-distribution","text":"Purpose : Place agents on existing geometry nodes instances Parameters : - Geo_Nodes Object : Geometry nodes object with instances output - Perfect for: Chair instances, predefined seating arrangements","title":"On Instance Distribution"},{"location":"static/stadium/#on-collection-objects","text":"Purpose : Distribute agents across objects in a collection Parameters : - On Collection : Target collection containing placement objects - Ideal for: Existing scene objects as placement points","title":"On Collection Objects"},{"location":"static/stadium/#on-vertex-distribution","text":"Purpose : Precise placement on mesh vertices with advanced controls Parameters : - On Vertix : Target mesh for vertex-based placement - Fill Factor : Density control (0.0-1.0) - Weight Paint Fill : Use vertex groups/weight painting for density variation","title":"On Vertex Distribution"},{"location":"static/stadium/#settings-panel","text":"Purpose : Fine-tune agent orientation and variation","title":"Settings Panel"},{"location":"static/stadium/#rotation","text":"Orientation Control : - Rotation Type : Method for agent rotation alignment - Options: Face normal, object direction, custom vectors","title":"Rotation"},{"location":"static/stadium/#random","text":"Variation Controls : - Mix Factor : Blend between perfect alignment and randomness - Rotation Min : Minimum random rotation offset - Rotation Max : Maximum random rotation offset - Rotation Seed : Randomization control for reproducible results","title":"Random"},{"location":"static/stadium/#at-object-panel","text":"Purpose : Advanced instance transformation controls Parameters : - At Object : Target object for placement - Randomize : Enable randomization features","title":"At Object Panel"},{"location":"static/stadium/#transformation-controls","text":"Instance Translation : - Offset : Position offset from base placement - Translation Local Space : Use local coordinates for offsets Instance Rotation : - Rotation Local Space : Local coordinate rotation - Advanced orientation adjustments Instance Scale : - Scale Local Space : Local coordinate scaling - Size variations within the formation","title":"Transformation Controls"},{"location":"static/stadium/#workflow","text":"","title":"Workflow"},{"location":"static/stadium/#phase-1-input-method-selection","text":"Choose based on your scene setup: Option A: On Face Method 1. Create a plane and scale/rotate to fit seating area 2. Ensure proper UV mapping on the face 3. Set Count X/Y for grid dimensions Option B: On Instance Method 1. Use Geometry Nodes to create chair/seat instances 2. Reference the GN object in the system 3. Agents automatically place on each instance Option C: On Collection Objects 1. Gather placement objects into a collection 2. Reference the collection in the system 3. Agents distribute across all collection objects Option D: On Vertex Method 1. Use mesh with vertex layout matching seating 2. Apply vertex groups/weight painting for density control 3. Adjust Fill Factor for overall density","title":"Phase 1: Input Method Selection"},{"location":"static/stadium/#phase-2-agent-configuration","text":"Select agent objects or collections Choose Object or Collection input type Set up agent properties and variations","title":"Phase 2: Agent Configuration"},{"location":"static/stadium/#phase-3-placement-refinement","text":"Adjust Rotation Type for proper orientation Use Random settings for natural variation Fine-tune Mix Factor for balance between order and randomness","title":"Phase 3: Placement Refinement"},{"location":"static/stadium/#phase-4-advanced-transformations","text":"Use At Object panel for specific placement adjustments Apply offsets and local transformations Adjust instance scaling for size variations","title":"Phase 4: Advanced Transformations"},{"location":"static/stadium/#use-cases","text":"","title":"Use Cases"},{"location":"static/stadium/#venue-seating","text":"Theater audiences Stadium crowds Concert seating arrangements Lecture hall populations","title":"Venue Seating"},{"location":"static/stadium/#event-planning","text":"Conference seating layouts Wedding ceremony arrangements Exhibition booth assignments Ceremonial formations","title":"Event Planning"},{"location":"static/stadium/#architectural-visualization","text":"Building occupancy simulations Space planning with populated areas Venue capacity testing","title":"Architectural Visualization"},{"location":"static/stadium/#entertainment-production","text":"Film/TV crowd scenes in venues Game level population Virtual event planning","title":"Entertainment Production"},{"location":"static/stadium/#advanced-techniques","text":"","title":"Advanced Techniques"},{"location":"static/stadium/#multi-method-workflow","text":"Combine On Face for main seating + On Vertex for VIP sections Use On Instance for fixed seating + On Collection for special areas Layer methods for complex venue layouts","title":"Multi-Method Workflow"},{"location":"static/stadium/#weight-painting-for-density","text":"Paint high-density areas for premium seating Create sparse areas for aisles and walkways Animate weight maps for dynamic crowd changes","title":"Weight Painting for Density"},{"location":"static/stadium/#geometry-nodes-integration","text":"Create sophisticated instance patterns with GN Use attribute-based variations for realistic seating Combine with scatter systems for hybrid approaches","title":"Geometry Nodes Integration"},{"location":"static/stadium/#key-features","text":"Multiple Input Methods : Flexible placement options for any scenario Precision Grid Control : Exact row/column arrangements with On Face Instance Awareness : Perfect alignment with existing geometry Vertex Group Integration : Advanced density control through weight painting Transformation Flexibility : Local/global space controls for perfect alignment Natural Variation : Controlled randomness for organic-looking crowds","title":"Key Features"},{"location":"static/stadium/#pro-tips","text":"","title":"Pro Tips"},{"location":"static/stadium/#face-method-best-practices","text":"Use a single quad face for best results Ensure proper UV scaling to match venue proportions Adjust Count X/Y to match actual seating dimensions","title":"Face Method Best Practices"},{"location":"static/stadium/#instance-method-optimization","text":"Pre-generate chair instances with Geometry Nodes Use instances with consistent orientation for uniform results Combine with vertex groups for section-based variations","title":"Instance Method Optimization"},{"location":"static/stadium/#vertex-method-advanced-use","text":"Create vertex groups for different ticket sections Use weight painting for gradual density transitions Animate vertex weights for crowd movement simulations The Static Stadium system provides venue-specific crowd distribution with architectural precision, offering multiple workflow options to match any seating arrangement scenario from simple theaters to complex stadium layouts.","title":"Vertex Method Advanced Use"},{"location":"static/scatter/curve/","text":"iCrowds Static On Curve Documentation Overview The Static On Curve system is a specialized tool for distributing agents along curves with intelligent density control based on curve radius. It enables artists to create natural-looking formations that follow paths, roads, or custom trajectories with radius-driven population density. Core Components Global Inputs Purpose : Define the base environment and agent sources Parameters : - Terrain : Reference surface for agent placement - Agents : Source objects or collections for distribution - Agent Input Type : Switch between Object or Collection input methods Curve Distribution System Purpose : Control agent placement along curves with radius-based density Density Panel Placement Methods : - Curve : Target curve object for agent distribution - Density Type : Method for calculating agent placement - Max : Maximum number of agents along the curve Count-Based Distribution Fixed Quantity Control : - Count Min : Minimum number of agents to place - Count Max : Maximum number of agents to place Length-Based Distribution Density-per-Length Control : - Length : Agents per unit length of the curve Radius Multiplier Panel Curve Radius Integration : - Radius Multiplier : Scale factor for curve radius influence on density - Feature: Use Alt+S curve point scaling to drive agent density variations Personal Space Purpose : Maintain natural spacing between agents along the curve Parameters : - Relax Iterations : Physics smoothing passes for optimal spacing - Space Min : Minimum distance between adjacent agents - Space Max : Maximum allowable spacing - Space Seed : Randomization for organic spacing variation Rotation Purpose : Control agent orientation along the curve path Parameters : - Up Direction : Surface normal alignment for agents - Look Direction : Forward orientation (typically follows curve direction) Random Purpose : Introduce controlled variation for natural results Parameters : - Random Min : Minimum random placement offset - Random Max : Maximum random placement offset - Random Seed : Randomization control for reproducible results At Object Panel Purpose : Object-based placement along curves Parameters : - At Object : Specific object targets for placement - Add Randomness : Introduce variation to object-based placement Position Variation Purpose : Fine-tune agent positioning relative to the curve Parameters : - Position Variation : Amount of positional randomness - Position Seed : Randomization control for position variations Scale Variations Purpose : Create size diversity among agents Parameters : - Scale Variation : Enable/disable agent size variations Key Innovation: Radius-Driven Density Curve Radius Control Unique Feature : The system uses the curve's radius (adjusted with Alt+S ) to dynamically control agent density: Wider Radius Areas : Higher agent density and more spacing flexibility Narrower Radius Areas : Lower agent density with tighter constraints Variable Radius Curves : Create natural density gradients along paths Radius Multiplier Application Multiplier > 1.0 : Amplify the radius's effect on density Multiplier < 1.0 : Reduce the radius's influence Multiplier = 0.0 : Disable radius-based density control Workflow Phase 1: Curve Preparation Create or import the target curve object Use Alt+S to scale curve points' radius for density control Adjust radius variations to define density hotspots and sparse areas Phase 2: Agent and Curve Setup Select the target curve for distribution Choose agent objects or collections Set Agent Input Type (Object or Collection) Phase 3: Distribution Method Selection Option A: Count-Based Placement 1. Set Count Min/Max for fixed agent quantities 2. System automatically distributes along curve length Option B: Density-Based Placement 1. Set Length parameter for agents per unit distance 2. Density automatically adapts to curve radius variations Phase 4: Radius Integration Adjust Radius Multiplier to control radius influence Fine-tune how curve point scaling affects density Balance between radius-driven and uniform distribution Phase 5: Spacing and Variation Configure Personal Space for natural agent separation Set Rotation parameters for proper orientation Add Random and Position variations for organic look Enable Scale Variations for size diversity Phase 6: Refinement Use At Object for specific placement requirements Adjust randomization seeds for controlled variation Fine-tune Max parameter to limit total agents Use Cases Road and Path Populations pedestrians along sidewalks vehicles on roads street furniture along pathways Event and Ceremony Layouts audience seating along procession routes participants in parade formations vendors along festival paths Natural Formations trees along riverbanks rocks along geological faults plants following terrain contours Architectural Applications people in queue lines furniture along building perimeters decorative elements along architectural features Advanced Techniques Dynamic Density Gradients Use gradually changing radius to create smooth density transitions Create crowded-to-sparse effects along paths Simulate natural gathering and dispersion patterns Multi-Curve Networks Distribute across multiple curves for complex layouts Use different radius settings for varied density zones Create hierarchical distribution patterns Animation Preparation Set up static formations for later fluid system integration Pre-define natural starting positions for dynamic simulations Create baseline distributions for motion systems Key Features Radius-Driven Density : Unique curve radius control over agent distribution Dual Distribution Methods : Choose between count-based or density-based placement Adaptive Spacing : Automatic adjustment based on curve characteristics Non-Linear Control : Curve point radius scaling for localized density effects Natural Orientation : Automatic rotation following curve direction Artist-Friendly : Visual curve editing with immediate density feedback The Static On Curve system provides intuitive control over path-based agent distribution, leveraging Blender's native curve editing tools to create natural, radius-driven population densities that adapt intelligently to path width variations.","title":"Scatter on Curve"},{"location":"static/scatter/curve/#icrowds-static-on-curve-documentation","text":"","title":"iCrowds Static On Curve Documentation"},{"location":"static/scatter/curve/#overview","text":"The Static On Curve system is a specialized tool for distributing agents along curves with intelligent density control based on curve radius. It enables artists to create natural-looking formations that follow paths, roads, or custom trajectories with radius-driven population density.","title":"Overview"},{"location":"static/scatter/curve/#core-components","text":"","title":"Core Components"},{"location":"static/scatter/curve/#global-inputs","text":"Purpose : Define the base environment and agent sources Parameters : - Terrain : Reference surface for agent placement - Agents : Source objects or collections for distribution - Agent Input Type : Switch between Object or Collection input methods","title":"Global Inputs"},{"location":"static/scatter/curve/#curve-distribution-system","text":"Purpose : Control agent placement along curves with radius-based density","title":"Curve Distribution System"},{"location":"static/scatter/curve/#density-panel","text":"Placement Methods : - Curve : Target curve object for agent distribution - Density Type : Method for calculating agent placement - Max : Maximum number of agents along the curve","title":"Density Panel"},{"location":"static/scatter/curve/#count-based-distribution","text":"Fixed Quantity Control : - Count Min : Minimum number of agents to place - Count Max : Maximum number of agents to place","title":"Count-Based Distribution"},{"location":"static/scatter/curve/#length-based-distribution","text":"Density-per-Length Control : - Length : Agents per unit length of the curve","title":"Length-Based Distribution"},{"location":"static/scatter/curve/#radius-multiplier-panel","text":"Curve Radius Integration : - Radius Multiplier : Scale factor for curve radius influence on density - Feature: Use Alt+S curve point scaling to drive agent density variations","title":"Radius Multiplier Panel"},{"location":"static/scatter/curve/#personal-space","text":"Purpose : Maintain natural spacing between agents along the curve Parameters : - Relax Iterations : Physics smoothing passes for optimal spacing - Space Min : Minimum distance between adjacent agents - Space Max : Maximum allowable spacing - Space Seed : Randomization for organic spacing variation","title":"Personal Space"},{"location":"static/scatter/curve/#rotation","text":"Purpose : Control agent orientation along the curve path Parameters : - Up Direction : Surface normal alignment for agents - Look Direction : Forward orientation (typically follows curve direction)","title":"Rotation"},{"location":"static/scatter/curve/#random","text":"Purpose : Introduce controlled variation for natural results Parameters : - Random Min : Minimum random placement offset - Random Max : Maximum random placement offset - Random Seed : Randomization control for reproducible results","title":"Random"},{"location":"static/scatter/curve/#at-object-panel","text":"Purpose : Object-based placement along curves Parameters : - At Object : Specific object targets for placement - Add Randomness : Introduce variation to object-based placement","title":"At Object Panel"},{"location":"static/scatter/curve/#position-variation","text":"Purpose : Fine-tune agent positioning relative to the curve Parameters : - Position Variation : Amount of positional randomness - Position Seed : Randomization control for position variations","title":"Position Variation"},{"location":"static/scatter/curve/#scale-variations","text":"Purpose : Create size diversity among agents Parameters : - Scale Variation : Enable/disable agent size variations","title":"Scale Variations"},{"location":"static/scatter/curve/#key-innovation-radius-driven-density","text":"","title":"Key Innovation: Radius-Driven Density"},{"location":"static/scatter/curve/#curve-radius-control","text":"Unique Feature : The system uses the curve's radius (adjusted with Alt+S ) to dynamically control agent density: Wider Radius Areas : Higher agent density and more spacing flexibility Narrower Radius Areas : Lower agent density with tighter constraints Variable Radius Curves : Create natural density gradients along paths","title":"Curve Radius Control"},{"location":"static/scatter/curve/#radius-multiplier-application","text":"Multiplier > 1.0 : Amplify the radius's effect on density Multiplier < 1.0 : Reduce the radius's influence Multiplier = 0.0 : Disable radius-based density control","title":"Radius Multiplier Application"},{"location":"static/scatter/curve/#workflow","text":"","title":"Workflow"},{"location":"static/scatter/curve/#phase-1-curve-preparation","text":"Create or import the target curve object Use Alt+S to scale curve points' radius for density control Adjust radius variations to define density hotspots and sparse areas","title":"Phase 1: Curve Preparation"},{"location":"static/scatter/curve/#phase-2-agent-and-curve-setup","text":"Select the target curve for distribution Choose agent objects or collections Set Agent Input Type (Object or Collection)","title":"Phase 2: Agent and Curve Setup"},{"location":"static/scatter/curve/#phase-3-distribution-method-selection","text":"Option A: Count-Based Placement 1. Set Count Min/Max for fixed agent quantities 2. System automatically distributes along curve length Option B: Density-Based Placement 1. Set Length parameter for agents per unit distance 2. Density automatically adapts to curve radius variations","title":"Phase 3: Distribution Method Selection"},{"location":"static/scatter/curve/#phase-4-radius-integration","text":"Adjust Radius Multiplier to control radius influence Fine-tune how curve point scaling affects density Balance between radius-driven and uniform distribution","title":"Phase 4: Radius Integration"},{"location":"static/scatter/curve/#phase-5-spacing-and-variation","text":"Configure Personal Space for natural agent separation Set Rotation parameters for proper orientation Add Random and Position variations for organic look Enable Scale Variations for size diversity","title":"Phase 5: Spacing and Variation"},{"location":"static/scatter/curve/#phase-6-refinement","text":"Use At Object for specific placement requirements Adjust randomization seeds for controlled variation Fine-tune Max parameter to limit total agents","title":"Phase 6: Refinement"},{"location":"static/scatter/curve/#use-cases","text":"","title":"Use Cases"},{"location":"static/scatter/curve/#road-and-path-populations","text":"pedestrians along sidewalks vehicles on roads street furniture along pathways","title":"Road and Path Populations"},{"location":"static/scatter/curve/#event-and-ceremony-layouts","text":"audience seating along procession routes participants in parade formations vendors along festival paths","title":"Event and Ceremony Layouts"},{"location":"static/scatter/curve/#natural-formations","text":"trees along riverbanks rocks along geological faults plants following terrain contours","title":"Natural Formations"},{"location":"static/scatter/curve/#architectural-applications","text":"people in queue lines furniture along building perimeters decorative elements along architectural features","title":"Architectural Applications"},{"location":"static/scatter/curve/#advanced-techniques","text":"","title":"Advanced Techniques"},{"location":"static/scatter/curve/#dynamic-density-gradients","text":"Use gradually changing radius to create smooth density transitions Create crowded-to-sparse effects along paths Simulate natural gathering and dispersion patterns","title":"Dynamic Density Gradients"},{"location":"static/scatter/curve/#multi-curve-networks","text":"Distribute across multiple curves for complex layouts Use different radius settings for varied density zones Create hierarchical distribution patterns","title":"Multi-Curve Networks"},{"location":"static/scatter/curve/#animation-preparation","text":"Set up static formations for later fluid system integration Pre-define natural starting positions for dynamic simulations Create baseline distributions for motion systems","title":"Animation Preparation"},{"location":"static/scatter/curve/#key-features","text":"Radius-Driven Density : Unique curve radius control over agent distribution Dual Distribution Methods : Choose between count-based or density-based placement Adaptive Spacing : Automatic adjustment based on curve characteristics Non-Linear Control : Curve point radius scaling for localized density effects Natural Orientation : Automatic rotation following curve direction Artist-Friendly : Visual curve editing with immediate density feedback The Static On Curve system provides intuitive control over path-based agent distribution, leveraging Blender's native curve editing tools to create natural, radius-driven population densities that adapt intelligently to path width variations.","title":"Key Features"},{"location":"static/scatter/ground/","text":"iCrowds Static On Ground Documentation Overview The Static On Ground system is a comprehensive terrain-based crowd distribution tool that scatters agents across surfaces with precise control over placement, density, and grouping. It supports both individual agent placement and clustered groupings for natural-looking crowd formations. Core Components Global Inputs Purpose : Define the base environment and agent sources Parameters : - Terrain : Base surface for agent placement - Agents : Source objects or collections for scattering - Agent Input Type : Switch between Object or Collection input methods Singles Distribution System Purpose : Place individual agents with controlled spacing and variation Density_Singles Panel Placement Controls : - Density_Singles : Overall agent concentration level - Min_Distance_Singles : Minimum spacing between individual agents - Seed_Singles : Randomization seed for placement variation - max_Singles : Maximum number of agents to place Masks_Singles Placement Restrictions : - Vertex Group Mask_Singles : Use vertex groups to define density areas - Inside Sphere Mask_Singles : Spherical boundary constraints Personal Space_Singles Natural Spacing : - Relax Iterations_Singles : Physics passes for optimal spacing - Space Min_Singles : Minimum personal space between agents - Space Max_Singles : Maximum personal space allowance - Space Seed_Singles : Randomization for natural spacing variation Rotation_Singles Orientation Control : - Up Direction_Singles : Surface normal alignment - Look Direction_Singles : Forward orientation direction Random_Singles Placement Variation : - Random Min_Singles : Minimum random offset - Random Max_Singles : Maximum random offset - Random Seed_Singles : Randomization control At Object_Singles Panel Object-Based Placement : - At Object_Singles : Target objects for placement - Add Randomness_Singles : Introduce variation to object-based placement Scale Variations_Singles Size Diversity : - Scale Variation_Singles : Enable/disable size variations - Scale Min_Singles : Minimum agent scale - Scale Max_Singles : Maximum agent scale - Scale Seed_Singles : Scale randomization control Clusters Distribution System Purpose : Create natural group formations with clustered agent placement Density_Clusters Panel Cluster Density : - Density_Clusters : Overall cluster concentration - Min Distance_Clusters : Spacing between cluster centers - Seed_Clusters : Cluster placement randomization - max_Clusters : Maximum number of clusters Mask_Clusters Cluster Placement Restrictions : - Vertex Group Mask_Clusters : Density control via vertex groups - Inside Sphere Mask_Clusters : Spherical boundary for clusters Cluster Variations_Clusters Group Configuration : - Radius_Clusters : Overall cluster size control - Radius Min_Clusters : Minimum cluster radius - Radius Max_Clusters : Maximum cluster radius - Radius Seed_Clusters : Cluster size randomization - Count_Clusters : Agents per cluster - Count Min_Clusters : Minimum agents per cluster - Count Max_Clusters : Maximum agents per cluster - Count Seed_Clusters : Agent count randomization Offset_Clusters Panel Placement Refinement : - Offset_Clusters : Enable cluster position offsets - Detail_Clusters : Offset refinement level - Random Offset_Clusters : Random position variation - Offset Min_Clusters : Minimum offset distance - Offset Max_Clusters : Maximum offset distance - Offset Seed_Clusters : Offset randomization Personal Space_Clusters Intra-Cluster Spacing : - Relax Iterations_Clusters : Physics smoothing within clusters - Space Min_Clusters : Minimum spacing between cluster members - Space Max_Clusters : Maximum spacing allowance - Space Seed_Clusters : Spacing variation control Rotation_Clusters Cluster Orientation : - Up Direction_Clusters : Surface alignment for clusters - Look Direction_Clusters : Cluster facing direction Random_Clusters Cluster Variation : - Random Min_Clusters : Minimum cluster variation - Random Max_Clusters : Maximum variation range - Random Seed_Clusters : Cluster randomization control Workflow Phase 1: Terrain and Agent Setup Define the base terrain surface for placement Select agent objects or collections for scattering Choose between Object or Collection input method Phase 2: Distribution Method Selection Option A: Singles Distribution 1. Configure density and minimum spacing parameters 2. Set up masking for controlled placement areas 3. Adjust personal space for natural agent spacing 4. Configure rotation and scale variations Option B: Clusters Distribution 1. Set cluster density and spacing between groups 2. Define cluster size parameters (radius and agent count) 3. Configure intra-cluster spacing and organization 4. Apply offsets and variations for natural group formations Phase 3: Masking and Refinement Use vertex groups to control density distribution Apply spherical masks for boundary control Fine-tune placement with offset and detail parameters Adjust randomization seeds for controlled variation Phase 4: Final Adjustments Review and tweak scale variations Optimize personal space parameters Finalize rotation and orientation settings Balance randomness for natural-looking results Use Cases Natural Environments Scattering vegetation and natural elements Wildlife placement in ecosystems Rock and debris distribution on terrain Urban Planning Pedestrian placement in public spaces Street furniture and object distribution Park and recreational area population Event Scenarios Audience seating arrangements Exhibition booth placement Festival attendee distribution Architectural Visualization People in building environments Furniture and object placement in interiors Context population around structures Key Features Dual Distribution Methods : Choose between individual or clustered placement Precise Density Control : Vertex group masking for area-specific density Natural Spacing Algorithms : Physics-based personal space optimization Comprehensive Randomization : Controlled variation for organic results Scalable Workflow : Handle from small scenes to massive distributions Non-Destructive Workflow : Parameters can be adjusted iteratively The Static On Ground system provides artist-friendly controls for creating believable, naturally distributed crowds and objects across any terrain surface, with advanced options for both individual placement and group formations.","title":"Scatter on Ground"},{"location":"static/scatter/ground/#icrowds-static-on-ground-documentation","text":"","title":"iCrowds Static On Ground Documentation"},{"location":"static/scatter/ground/#overview","text":"The Static On Ground system is a comprehensive terrain-based crowd distribution tool that scatters agents across surfaces with precise control over placement, density, and grouping. It supports both individual agent placement and clustered groupings for natural-looking crowd formations.","title":"Overview"},{"location":"static/scatter/ground/#core-components","text":"","title":"Core Components"},{"location":"static/scatter/ground/#global-inputs","text":"Purpose : Define the base environment and agent sources Parameters : - Terrain : Base surface for agent placement - Agents : Source objects or collections for scattering - Agent Input Type : Switch between Object or Collection input methods","title":"Global Inputs"},{"location":"static/scatter/ground/#singles-distribution-system","text":"Purpose : Place individual agents with controlled spacing and variation","title":"Singles Distribution System"},{"location":"static/scatter/ground/#density_singles-panel","text":"Placement Controls : - Density_Singles : Overall agent concentration level - Min_Distance_Singles : Minimum spacing between individual agents - Seed_Singles : Randomization seed for placement variation - max_Singles : Maximum number of agents to place","title":"Density_Singles Panel"},{"location":"static/scatter/ground/#masks_singles","text":"Placement Restrictions : - Vertex Group Mask_Singles : Use vertex groups to define density areas - Inside Sphere Mask_Singles : Spherical boundary constraints","title":"Masks_Singles"},{"location":"static/scatter/ground/#personal-space_singles","text":"Natural Spacing : - Relax Iterations_Singles : Physics passes for optimal spacing - Space Min_Singles : Minimum personal space between agents - Space Max_Singles : Maximum personal space allowance - Space Seed_Singles : Randomization for natural spacing variation","title":"Personal Space_Singles"},{"location":"static/scatter/ground/#rotation_singles","text":"Orientation Control : - Up Direction_Singles : Surface normal alignment - Look Direction_Singles : Forward orientation direction","title":"Rotation_Singles"},{"location":"static/scatter/ground/#random_singles","text":"Placement Variation : - Random Min_Singles : Minimum random offset - Random Max_Singles : Maximum random offset - Random Seed_Singles : Randomization control","title":"Random_Singles"},{"location":"static/scatter/ground/#at-object_singles-panel","text":"Object-Based Placement : - At Object_Singles : Target objects for placement - Add Randomness_Singles : Introduce variation to object-based placement","title":"At Object_Singles Panel"},{"location":"static/scatter/ground/#scale-variations_singles","text":"Size Diversity : - Scale Variation_Singles : Enable/disable size variations - Scale Min_Singles : Minimum agent scale - Scale Max_Singles : Maximum agent scale - Scale Seed_Singles : Scale randomization control","title":"Scale Variations_Singles"},{"location":"static/scatter/ground/#clusters-distribution-system","text":"Purpose : Create natural group formations with clustered agent placement","title":"Clusters Distribution System"},{"location":"static/scatter/ground/#density_clusters-panel","text":"Cluster Density : - Density_Clusters : Overall cluster concentration - Min Distance_Clusters : Spacing between cluster centers - Seed_Clusters : Cluster placement randomization - max_Clusters : Maximum number of clusters","title":"Density_Clusters Panel"},{"location":"static/scatter/ground/#mask_clusters","text":"Cluster Placement Restrictions : - Vertex Group Mask_Clusters : Density control via vertex groups - Inside Sphere Mask_Clusters : Spherical boundary for clusters","title":"Mask_Clusters"},{"location":"static/scatter/ground/#cluster-variations_clusters","text":"Group Configuration : - Radius_Clusters : Overall cluster size control - Radius Min_Clusters : Minimum cluster radius - Radius Max_Clusters : Maximum cluster radius - Radius Seed_Clusters : Cluster size randomization - Count_Clusters : Agents per cluster - Count Min_Clusters : Minimum agents per cluster - Count Max_Clusters : Maximum agents per cluster - Count Seed_Clusters : Agent count randomization","title":"Cluster Variations_Clusters"},{"location":"static/scatter/ground/#offset_clusters-panel","text":"Placement Refinement : - Offset_Clusters : Enable cluster position offsets - Detail_Clusters : Offset refinement level - Random Offset_Clusters : Random position variation - Offset Min_Clusters : Minimum offset distance - Offset Max_Clusters : Maximum offset distance - Offset Seed_Clusters : Offset randomization","title":"Offset_Clusters Panel"},{"location":"static/scatter/ground/#personal-space_clusters","text":"Intra-Cluster Spacing : - Relax Iterations_Clusters : Physics smoothing within clusters - Space Min_Clusters : Minimum spacing between cluster members - Space Max_Clusters : Maximum spacing allowance - Space Seed_Clusters : Spacing variation control","title":"Personal Space_Clusters"},{"location":"static/scatter/ground/#rotation_clusters","text":"Cluster Orientation : - Up Direction_Clusters : Surface alignment for clusters - Look Direction_Clusters : Cluster facing direction","title":"Rotation_Clusters"},{"location":"static/scatter/ground/#random_clusters","text":"Cluster Variation : - Random Min_Clusters : Minimum cluster variation - Random Max_Clusters : Maximum variation range - Random Seed_Clusters : Cluster randomization control","title":"Random_Clusters"},{"location":"static/scatter/ground/#workflow","text":"","title":"Workflow"},{"location":"static/scatter/ground/#phase-1-terrain-and-agent-setup","text":"Define the base terrain surface for placement Select agent objects or collections for scattering Choose between Object or Collection input method","title":"Phase 1: Terrain and Agent Setup"},{"location":"static/scatter/ground/#phase-2-distribution-method-selection","text":"Option A: Singles Distribution 1. Configure density and minimum spacing parameters 2. Set up masking for controlled placement areas 3. Adjust personal space for natural agent spacing 4. Configure rotation and scale variations Option B: Clusters Distribution 1. Set cluster density and spacing between groups 2. Define cluster size parameters (radius and agent count) 3. Configure intra-cluster spacing and organization 4. Apply offsets and variations for natural group formations","title":"Phase 2: Distribution Method Selection"},{"location":"static/scatter/ground/#phase-3-masking-and-refinement","text":"Use vertex groups to control density distribution Apply spherical masks for boundary control Fine-tune placement with offset and detail parameters Adjust randomization seeds for controlled variation","title":"Phase 3: Masking and Refinement"},{"location":"static/scatter/ground/#phase-4-final-adjustments","text":"Review and tweak scale variations Optimize personal space parameters Finalize rotation and orientation settings Balance randomness for natural-looking results","title":"Phase 4: Final Adjustments"},{"location":"static/scatter/ground/#use-cases","text":"","title":"Use Cases"},{"location":"static/scatter/ground/#natural-environments","text":"Scattering vegetation and natural elements Wildlife placement in ecosystems Rock and debris distribution on terrain","title":"Natural Environments"},{"location":"static/scatter/ground/#urban-planning","text":"Pedestrian placement in public spaces Street furniture and object distribution Park and recreational area population","title":"Urban Planning"},{"location":"static/scatter/ground/#event-scenarios","text":"Audience seating arrangements Exhibition booth placement Festival attendee distribution","title":"Event Scenarios"},{"location":"static/scatter/ground/#architectural-visualization","text":"People in building environments Furniture and object placement in interiors Context population around structures","title":"Architectural Visualization"},{"location":"static/scatter/ground/#key-features","text":"Dual Distribution Methods : Choose between individual or clustered placement Precise Density Control : Vertex group masking for area-specific density Natural Spacing Algorithms : Physics-based personal space optimization Comprehensive Randomization : Controlled variation for organic results Scalable Workflow : Handle from small scenes to massive distributions Non-Destructive Workflow : Parameters can be adjusted iteratively The Static On Ground system provides artist-friendly controls for creating believable, naturally distributed crowds and objects across any terrain surface, with advanced options for both individual placement and group formations.","title":"Key Features"},{"location":"static/scatter/vertex/","text":"iCrowds Static On Vertex Documentation Overview The Static On Vertex system is a mesh-based distribution tool that places agents precisely on mesh vertices with controlled variation and spacing. It enables exact placement control using existing mesh topology while maintaining natural-looking variations through comprehensive randomization options. Core Components Global Inputs Purpose : Define the base environment and agent sources Parameters : - Terrain : Reference surface for orientation and placement context - Agents : Source objects or collections for vertex-based distribution - Agent Input Type : Switch between Object or Collection input methods Vertex Distribution System Purpose : Control agent placement directly on mesh vertices Density Panel Placement Controls : - Mesh : Target mesh object whose vertices will host agents - Max : Maximum number of agents to place (vertex-limited) - Feature: Vertex group masking for selective placement Personal Space Purpose : Maintain natural spacing between vertex-placed agents Parameters : - Relax Iterations : Physics smoothing passes for optimal vertex spacing - Space Min : Minimum distance between agents on adjacent vertices - Space Max : Maximum allowable spacing adjustment - Space Seed : Randomization for organic spacing variation Position Variations Purpose : Introduce controlled offsets from exact vertex positions Parameters : - Position Variation : Amount of positional randomness from vertex centers - Position Seed : Randomization control for position variations Rotation Variations Purpose : Control agent orientation on vertices Parameters : - Up Direction : Surface normal alignment for natural standing - Look Direction : Forward orientation control (random or directed) Random Purpose : Additional randomization for natural distribution Parameters : - Random Min : Minimum random influence - Random Max : Maximum random influence - Random Seed : Overall randomization control At Object Panel Purpose : Object-specific vertex placement Parameters : - At Object : Target specific objects for vertex placement - Add Randomness : Introduce variation to object-based placement Scale Variations Purpose : Create size diversity among vertex-placed agents Parameters : - Scale Variation : Enable/disable agent size variations - Scale Min : Minimum agent scale factor - Scale Max : Maximum agent scale factor - Scale Seed : Scale randomization control Key Innovation: Vertex-Based Precision with Natural Variation Exact Vertex Placement Core Feature : Agents are placed precisely on mesh vertices while maintaining organic feel: Vertex-Level Control : Each agent corresponds to a specific vertex Topology-Driven : Distribution follows mesh edge flow and density Non-Destructive : Original mesh remains untouched Vertex Group Masking Advanced Control : Use vertex groups to selectively enable/disable placement: Density Zones : Create high-density and sparse areas using vertex weights Pattern Control : Design specific formation patterns through vertex selection Animated Masks : Use animated vertex groups for dynamic placement changes Workflow Phase 1: Mesh Preparation Create or import the target mesh with appropriate vertex density Use vertex groups to define placement zones and density variations Ensure mesh has sufficient vertices for desired agent count Phase 2: Agent and Mesh Setup Select the target mesh for vertex-based distribution Choose agent objects or collections Set Agent Input Type (Object or Collection) Phase 3: Density Configuration Set Max parameter to control total agent count System automatically uses available vertices up to the maximum Vertex group masks automatically limit placement to weighted areas Phase 4: Spacing and Naturalization Configure Personal Space to prevent overcrowding on dense vertices Adjust Position Variations for organic offsets from exact vertex positions Set Rotation parameters for natural orientation Phase 5: Variation Controls Enable Scale Variations for size diversity Use Random parameters to introduce controlled chaos Fine-tune randomization seeds for reproducible results Phase 6: Advanced Placement Use At Object for specific object targeting Apply additional randomness for object-based variations Balance exact placement with natural-looking results Use Cases Architectural Precision People placed exactly on seating vertices Furniture on floor plan vertices Decorative elements on architectural features Event Planning Audience members on seating vertices Participants in organized formations Exhibits on precise layout points Natural Distributions Plants on terrain vertices following contours Rocks on geological feature vertices Animals on ecosystem analysis points Technical Applications Data visualization with agent representation Sensor placement simulations Urban planning with exact positioning Advanced Techniques Vertex Group Masking Strategies Weight-Based Density : Use vertex weights to control probability of placement Pattern Creation : Design specific formations through vertex selection Animated Distributions : Animate vertex groups for moving placement zones Multi-Mesh Distributions Combine multiple meshes for complex distributions Use different vertex densities for varied concentration areas Create hierarchical placement systems Hybrid Approaches Combine vertex placement with other distribution methods Use vertex system for base placement with other systems for variation Create layered distribution effects Key Features Precision Placement : Exact control through mesh vertices Vertex Group Masking : Advanced selective placement control Natural Variation : Comprehensive randomization while maintaining structure Topology-Aware : Distribution follows mesh flow and density Non-Destructive : Original mesh remains intact Scalable : Works with simple to complex meshes Performance Considerations Vertex Count : Performance scales with vertex quantity Optimization : Use optimized meshes with appropriate vertex density LOD Strategies : Implement level-of-detail for distant distributions The Static On Vertex system provides the perfect balance between precision control and natural variation, allowing artists to create exact formations while maintaining organic-looking results through comprehensive variation controls and vertex group masking capabilities.","title":"Scatter on Vertex"},{"location":"static/scatter/vertex/#icrowds-static-on-vertex-documentation","text":"","title":"iCrowds Static On Vertex Documentation"},{"location":"static/scatter/vertex/#overview","text":"The Static On Vertex system is a mesh-based distribution tool that places agents precisely on mesh vertices with controlled variation and spacing. It enables exact placement control using existing mesh topology while maintaining natural-looking variations through comprehensive randomization options.","title":"Overview"},{"location":"static/scatter/vertex/#core-components","text":"","title":"Core Components"},{"location":"static/scatter/vertex/#global-inputs","text":"Purpose : Define the base environment and agent sources Parameters : - Terrain : Reference surface for orientation and placement context - Agents : Source objects or collections for vertex-based distribution - Agent Input Type : Switch between Object or Collection input methods","title":"Global Inputs"},{"location":"static/scatter/vertex/#vertex-distribution-system","text":"Purpose : Control agent placement directly on mesh vertices","title":"Vertex Distribution System"},{"location":"static/scatter/vertex/#density-panel","text":"Placement Controls : - Mesh : Target mesh object whose vertices will host agents - Max : Maximum number of agents to place (vertex-limited) - Feature: Vertex group masking for selective placement","title":"Density Panel"},{"location":"static/scatter/vertex/#personal-space","text":"Purpose : Maintain natural spacing between vertex-placed agents Parameters : - Relax Iterations : Physics smoothing passes for optimal vertex spacing - Space Min : Minimum distance between agents on adjacent vertices - Space Max : Maximum allowable spacing adjustment - Space Seed : Randomization for organic spacing variation","title":"Personal Space"},{"location":"static/scatter/vertex/#position-variations","text":"Purpose : Introduce controlled offsets from exact vertex positions Parameters : - Position Variation : Amount of positional randomness from vertex centers - Position Seed : Randomization control for position variations","title":"Position Variations"},{"location":"static/scatter/vertex/#rotation-variations","text":"Purpose : Control agent orientation on vertices Parameters : - Up Direction : Surface normal alignment for natural standing - Look Direction : Forward orientation control (random or directed)","title":"Rotation Variations"},{"location":"static/scatter/vertex/#random","text":"Purpose : Additional randomization for natural distribution Parameters : - Random Min : Minimum random influence - Random Max : Maximum random influence - Random Seed : Overall randomization control","title":"Random"},{"location":"static/scatter/vertex/#at-object-panel","text":"Purpose : Object-specific vertex placement Parameters : - At Object : Target specific objects for vertex placement - Add Randomness : Introduce variation to object-based placement","title":"At Object Panel"},{"location":"static/scatter/vertex/#scale-variations","text":"Purpose : Create size diversity among vertex-placed agents Parameters : - Scale Variation : Enable/disable agent size variations - Scale Min : Minimum agent scale factor - Scale Max : Maximum agent scale factor - Scale Seed : Scale randomization control","title":"Scale Variations"},{"location":"static/scatter/vertex/#key-innovation-vertex-based-precision-with-natural-variation","text":"","title":"Key Innovation: Vertex-Based Precision with Natural Variation"},{"location":"static/scatter/vertex/#exact-vertex-placement","text":"Core Feature : Agents are placed precisely on mesh vertices while maintaining organic feel: Vertex-Level Control : Each agent corresponds to a specific vertex Topology-Driven : Distribution follows mesh edge flow and density Non-Destructive : Original mesh remains untouched","title":"Exact Vertex Placement"},{"location":"static/scatter/vertex/#vertex-group-masking","text":"Advanced Control : Use vertex groups to selectively enable/disable placement: Density Zones : Create high-density and sparse areas using vertex weights Pattern Control : Design specific formation patterns through vertex selection Animated Masks : Use animated vertex groups for dynamic placement changes","title":"Vertex Group Masking"},{"location":"static/scatter/vertex/#workflow","text":"","title":"Workflow"},{"location":"static/scatter/vertex/#phase-1-mesh-preparation","text":"Create or import the target mesh with appropriate vertex density Use vertex groups to define placement zones and density variations Ensure mesh has sufficient vertices for desired agent count","title":"Phase 1: Mesh Preparation"},{"location":"static/scatter/vertex/#phase-2-agent-and-mesh-setup","text":"Select the target mesh for vertex-based distribution Choose agent objects or collections Set Agent Input Type (Object or Collection)","title":"Phase 2: Agent and Mesh Setup"},{"location":"static/scatter/vertex/#phase-3-density-configuration","text":"Set Max parameter to control total agent count System automatically uses available vertices up to the maximum Vertex group masks automatically limit placement to weighted areas","title":"Phase 3: Density Configuration"},{"location":"static/scatter/vertex/#phase-4-spacing-and-naturalization","text":"Configure Personal Space to prevent overcrowding on dense vertices Adjust Position Variations for organic offsets from exact vertex positions Set Rotation parameters for natural orientation","title":"Phase 4: Spacing and Naturalization"},{"location":"static/scatter/vertex/#phase-5-variation-controls","text":"Enable Scale Variations for size diversity Use Random parameters to introduce controlled chaos Fine-tune randomization seeds for reproducible results","title":"Phase 5: Variation Controls"},{"location":"static/scatter/vertex/#phase-6-advanced-placement","text":"Use At Object for specific object targeting Apply additional randomness for object-based variations Balance exact placement with natural-looking results","title":"Phase 6: Advanced Placement"},{"location":"static/scatter/vertex/#use-cases","text":"","title":"Use Cases"},{"location":"static/scatter/vertex/#architectural-precision","text":"People placed exactly on seating vertices Furniture on floor plan vertices Decorative elements on architectural features","title":"Architectural Precision"},{"location":"static/scatter/vertex/#event-planning","text":"Audience members on seating vertices Participants in organized formations Exhibits on precise layout points","title":"Event Planning"},{"location":"static/scatter/vertex/#natural-distributions","text":"Plants on terrain vertices following contours Rocks on geological feature vertices Animals on ecosystem analysis points","title":"Natural Distributions"},{"location":"static/scatter/vertex/#technical-applications","text":"Data visualization with agent representation Sensor placement simulations Urban planning with exact positioning","title":"Technical Applications"},{"location":"static/scatter/vertex/#advanced-techniques","text":"","title":"Advanced Techniques"},{"location":"static/scatter/vertex/#vertex-group-masking-strategies","text":"Weight-Based Density : Use vertex weights to control probability of placement Pattern Creation : Design specific formations through vertex selection Animated Distributions : Animate vertex groups for moving placement zones","title":"Vertex Group Masking Strategies"},{"location":"static/scatter/vertex/#multi-mesh-distributions","text":"Combine multiple meshes for complex distributions Use different vertex densities for varied concentration areas Create hierarchical placement systems","title":"Multi-Mesh Distributions"},{"location":"static/scatter/vertex/#hybrid-approaches","text":"Combine vertex placement with other distribution methods Use vertex system for base placement with other systems for variation Create layered distribution effects","title":"Hybrid Approaches"},{"location":"static/scatter/vertex/#key-features","text":"Precision Placement : Exact control through mesh vertices Vertex Group Masking : Advanced selective placement control Natural Variation : Comprehensive randomization while maintaining structure Topology-Aware : Distribution follows mesh flow and density Non-Destructive : Original mesh remains intact Scalable : Works with simple to complex meshes","title":"Key Features"},{"location":"static/scatter/vertex/#performance-considerations","text":"Vertex Count : Performance scales with vertex quantity Optimization : Use optimized meshes with appropriate vertex density LOD Strategies : Implement level-of-detail for distant distributions The Static On Vertex system provides the perfect balance between precision control and natural variation, allowing artists to create exact formations while maintaining organic-looking results through comprehensive variation controls and vertex group masking capabilities.","title":"Performance Considerations"}]}